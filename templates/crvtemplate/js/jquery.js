/ *! jQuery v3.2.1 | (c) Fundación JS y otros colaboradores | jquery.org/license * /
function (a, b) {"use strict"; "object" == tipo de módulo && "objeto" == typeof module.exports? module.exports = a.document? b (a,! 0): function (a) {if (! a.document) throw new Error ("jQuery requiere una ventana con un documento"); return b (a)}: b (a)} ("undefined"! a, b) {"use strict"; var c = [], d = a.document, e = Object.getPrototypeOf, f = c.slice, g = c.concat, h = c.push, i = c. (=), o = {}, función p (a, b) {b = b (c)) var q = "3.2.1", r = función (es decir, c) (a, b) {return new r.fn.init (a, b)}, s = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, t = g, v = función (a, b) {return b.toUpperCase ()}; r.fn = r.prototype = {jquery: q, constructor: r, longitud:0, toArray: function () {return f.call (this)}, get: función (a) {return null == a? F.call (this): a <0? This [a + this.length]: esto [a]}, pushStack: function (a) {var b = r.merge (this.constructor (), a); return b.prevObject = this, b}, each: function (a) {return r.each (this, a)}, map: función (a) {return this.pushStack (r.map (esto, función (b, c) {return a.call (b, c, b) () {return this.eq (0)}, last: function () {return this.eq (-1)} , eq: function (a) {var b = this.length, c = + a + (a <0? b: 0), devuelve this.pushStack (c> = 0 && c <b? )}, end: function () {return this.prevObject || this.constructor ()}, push: h, sort: c.sort, splice: c.splice}, r.extend = r.fn.extend = function () {var a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = arguments.length, j =! 1; for ("boolean" == typeof g && (j = g, g = argumentos [h] || {}, h ++), "(g = h, h) h (i = h) h (h) = h (h) a = argumentos [h])) para (b en a) c = g [b], d = a [b], g! == d && (d && (r.isPlainObject (d) || (e = Array.isArray (c)? (e) (e = (1, f = c && Array.isArray (c)? c: []): f = c && r.isPlainObject (j, f, d)): void 0! == d && (g [b] = d)); return g}, r.extend ({expando: "jQuery" + (q + Math.random) Función: Función (a) {return (error)) Función: Función (a) es función: = función (a) {var b = r.type (a) {return null! = a && a === a.window}, isNumeric: function (a) ; return ("number" === b || "string" === b) &&! isNaN (a-parseFloat (a))}, esPlainObject: function (a) {var b, c; return! || "[object Objeto]"! == k.call (a)) && (!(b = e (a)) || (c = l.call (b, "constructor") && b.constructor, "function" == typeof c && m.call (c) === n))}, isEmptyObject: function (a) {var b; para (b en a) return! 1; return! 0}, tipo: function (a) {return null == a? a + "": "object" == typeof a || "function () () a) () () () () () () () () () () () () () (a, b) {var c, d = 0, si (w (a)) {para (c = a.length; d < d) d) d) d) d) d) d) d) d) d) d) d = a) {return null == a? "" :( a + ""). replace (s, "")}, makeArray: (a, b) {var c = b || []; devuelve null! = a && (w (objeto (a))? r.merge (c, : h.call (c, a)), c}, inArray: función (a, b,c) {return null == b? -1: i.call (b, a, c)}, merge: función (a, b) {for (var c = + b.length, d = 0, e = a (a, b, c) {para (var d, e = [], d) f = 0, g = a.length, h = c c f f g f f d f f d f f d d f f }, mapa: función (a, b, c) {var d, e, f = 0, h = []; si (w (a)) para (d = a.length; b (a [f], f, c), null! = e && h.push (e), sino para (f en a) e = b (a [f], f, c) (), gui: 1, proxy: función (a, b) {var c, d, e; if ("string" = = tipo de b && (c = a [b ], b = a, a = c), r.isFunción (a)) devuelve d = f.call (argumentos, 2), e = function () {return a.apply (b || this, d.concat f.call (argumentos))}, e.guid = a.guid = a.guid || r.guid ++, e}, ahora: Date.now, support: o}), "function" == typeof Symbol && r.fn [Symbol.iterator] = c [Symbol.iterator]), r.each ("Boolean Number String Función Array Fecha RegExp Objeto Error Símbolo ".split (" "), función (a, b) {j [" [objeto "+ b +"] "] = b.toLowerCase () ) {var b = !! a && "longitud" en && a.length, c = r.type (a); return "function"! == c &&! r.isWindow (a) && ("array" === c | Var = función (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Fecha, v = a.documento, w = 0, x = 0, , = = (), A = ha (), B = función (a, b) {return a === b && (l =! 0), 0}, C = E = D.pop, F = D.push, G = D.push, H = D.slice, I = función (a, b) {for (var c = 0, d = a.length; c <d; c ++) if (a [c] === b) devuelve c; return-1}, J = "seleccionado | asincrónico | autofocus | autoplay | controles | aplazar | deshabilitado | oculto | ismap | bucle | múltiple | abierto | readonly | necesario | scoped ", K =" [\\ x20 \\ t \\ r \\ n \ \ f] ", L =" (?: \\\\. | [\\ w-] | ^ \ 0 - \\ xa0)) + ", M =" \\ ["+ K + + L + ") (?: \\\\. | [^ \\\\ ' Unesdoc.unesco.org unesdoc.unesco.org Nd bf bb bb bb bb bb bb bb bb Unesdoc.unesco.org unesdoc.unesco.org ) *)), O = nuevo RegExp (K + "+", "g"), P = nuevo RegExp ("^" + K + "+ | (?: ^ | [^ +) "), Q = new RegExp (" ^ "+ K +" *, "+ K +" * ") (?: \\\\. , R = nuevo RegExp ("^" + K + "* ([> + ~] |"+ K + "+" + K + "*"), S = nuevo RegExp ("=" + K + "* ([^ \\] ), T = new RegExp (N), U = nuevo RegExp ("^" + L + "$"), V = {ID: new RegExp ), ATTR: new RegExp ("^" + M), PSEUDO: new RegExp ("+ L +") ("^" + N), CHILD: new RegExp ("^ :( sólo | primero | último | nth | nth-último) - (child | of-type) (?: \\ (" + K + impares |||||||||||||||%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ("+"), NeedsContext: new RegExp ("^" + K + "*") [> + ~] |: (incluso | impar | eq | gt | lt | nth | primero | último) (?: \\ ("+ K +" * ((?: - \\ d)? \\ d *) Unesdoc.unesco.org unesdoc.unesco.org/ i, X = / ^ h \ d $ / i, Y = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Z = / ^ (?: # ([\ w-] +) | (\ w +) | \. ([\ w -] +)) $ /, $ = / [+ ~ /, _ = new RegExp ("\\\\ ([\\ da-f] {1,6}" + K + "? | (" + K + ") (d + 65536): String.fromCharCode (d> 65536): String.fromCharCode (d + 65536) > 10 | 55296,1023 & d | 56320)}, ba = \ ff \ ff \ f \ -] / g, ca = función (a, b) {return b? "\ 0" === a? "\ ufffd": a.slice (0, -1) + "\\" + a.charCodeAt a.length-1) .toString (16) + "": "\\" + a}, da = function () {m ()}, ea = ta (función (a) {return a.disabled === {0} && ("form" en un || "etiqueta" en a)}, {dir: "parentNode", next: v.childNodes), D [v.childNodes.length].(a, b)): función (a, b) {var c = a. (a, b, d, e) {var f, h, j, k, a, d = 0; si, (d = d || [], "string"! = tipo de un ||! a || 1! == w && 9 == w && 11! == w) return d; if (! e && (b? b.ownerDocument || b: v)! == n && m (b), b = b || n, p) 11 == w && (l = Z.exec (a))) if (f = l [1]) {if (9 === w) {if (! (J = b.getElementById (f))) return d, if (j.id === f) devuelve d.push (j), d} else si (s && (j = s.getElementById (f)) && t (b, j) && j.id === f) (d, b.getElementsByTagName (a)), d; si ((f = l [3]) && c.getElementsByClassName && b. getElementsByClassName) devuelve G.apply (d, b.getElementsByClassName (f)), d} if (c.qsa &&! A [a + ""] && (! q ||! q.prueba (a))) {if (1! == w) s = b, r = a; else if ("objeto"! == b.nodeName.toLowerCase ()) {(k = b.getAttribute ("id ") k = k.replace (ba, ca): b.setAttribute (" id ", k = u), o = g (a), h = o.length; ] = "#" + k + "" + sa (o [h]); r = o.join (","), s = $. test (a) && qa (b.parentNode) || b} if (r ) try {return G.apply (d, s.querySelectorAll (r)), d} catch (x) {} finalmente {k === u && b.removeAttribute ("id")}}} return i (a.replace P, "$ 1"), b, d, e)} función ha () {var a = []; función b (c, e) {return a.push (c + "")> d.cacheLength && delete b [a. (a) {return a [u] =! 0, a} función ja (a) {var b = n.createElement ("fieldset" ); try {return! a (b)} catch (c) {return! 1} finalmente {b.parentNode && b.parentNode.removeChild (b), b = null}} función ka (a, b) a.split ("|"), e = c.longitud, mientras que (e -) d.attrHandle [c [e]] = b} función la (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex -b.sourceIndex; si d) devuelve d; si c) while (c = c.nextSibling) if (c === b) return-1; devuelve a 1: -1} función ma (a) { (b) {var c = b.nodeName.toLowerCase (); return "input" === c && b.type === a}} función na (a) {función de retorno (b) {var c = b. a) {función de retorno (b) {return "forma") = en b? b.parentNode && b.disabled ===! 1? etiqueta "en b?" etiqueta "en b.parentNode? b.parentNode.disabled === a: b.disabled === a: b.isDisabled = == a || b.isDisabled! ==! a && ea (b) === a: b.disabled === a: "label" en b && b.disabled === a}} función pa (a) {return ia (función (b) {return b = + b,(c, d) {var e, f = a ([], c.length, b), g = f.length; mientras que (g -) c [e = f [g] [e] =! (d [e] = c [e]))})})} función qa (a) {return a && "undefined"! = typeof a.getElementsByTagName && a} c = ga.support = {} = ga.isXML = function (a) {var b = a && (a.ownerDocument || a) .documentElement; return !! b && "HTML"! == b.nodeName}, m = ga.setDocument = function (a) {var b, e, g = a? a.ownerDocument || a: v; return g! == n && 9 === g.nodeType && g.documentElement? (n = g, o = n.documentElement, p =! f (e.addEventListener? e.addEventListener ("unload", da,! 1): e.attachEvent && e.attachEvent ("onunload" , da)), c.attributes = ja (function (a) {return a.className = "i",! a.getAttribute ("className")}), c.getElementsByTagName = .appendChild (n.createComment ("")), a.getElementsByTagName ("*"). length}), c.getElementsByClassName = Y.test (n.getElementsByClassName), c.getById = ja (function (a) {return o.appendChild a) .id = u,! n.getElementsByName ||! n.getElementsByName (u) .length}), c.getById? (d.filter.ID = function (a) {var b = a.replace (_, aa); return función (a) {return a.getAttribute ("id") === b}}, d.find.ID = función (a, b) {if ("undefined"! = typeof b.getElementById && p) {var c = b.getElementById (a); return c? [c]: []}} :( d.filter.ID = función (a) {var b = a.replace (_, aa) (a) {dc = "undefined"! = typeof a.getAttributeNode && a.getAttributeNode ("id"); return c && c.value === b}}, d.find.ID = función (a, b) (a); if (f) {if (c = f.getAttributeNode ("id"), es decir,c && c.value === a) return [f]; e = b.getElementsByName (a), d = 0; mientras que (f = e [d ++]) if (c = f.getAttributeNode ("id"), c && c. valor === a) return [f]} return []}}, d.find.TAG = c.getElementsByTagName? function (a, b) {return "undefined"! = typeof b.getElementsByTagName? b.getElementsByTagName a): c.qsa? b.querySelectorAll (a): void 0}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a) === a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); return d} return f}, d.find.CLASS = c.getElementsByClassName && function {if ("undefined"! = typeof b.getElementsByClassName && p) return b.getElementsByClassName (a)}, r = [], q = [], (c.qsa = Y.test (n.querySelectorAll) function (a) {o.appendChild (a) .innerHTML = "<a id='"+u+"'> </a> <select id = '" + u + "- \ r \\' msallowcapture = ''> <option selected =' '> </ option> </ select> ", a.querySelectorAll (" [msallowcapture ^ =' '] (?: '' | \ "\") "), a.querySelectorAll (" [selected] "). length || q.push (" \\ ["+ ), a.querySelectorAll ("[id ~ =" + u + "-]") length || q.push ("~ ="), a.querySelectorAll (": checked") length || q. (a) (): () () () () () () () () () () () {a.innerHTML = "<a href='' disabled='disabled'> </a> <select disabled = 'disabled'> <b> var <b> = n.createElement (" input " ); b.setAttribute ("type", "ocultos "), a.appendChild (b) .setAttribute (" nombre "," D "), a.querySelectorAll (" [name = d] ") length && q.push (" name "+ K + (=: Activado), o.appendChild (a) .disabled =! 0,? =?), 2! == a.querySelectorAll (": enabled" 2 == a.querySelectorAll (": disabled") length && q.push (": enabled", ": disabled"), a.querySelectorAll ("* ,: x"), q.push (",. *: () () () () () () () () () () () () () .disconnectedMatch = s.call (a, "*"), s.call (a, "[s! = '']: x"), r.push ("! =", N)}, q = q .length && new RegExp (q.join ("|")), r = r.length && new RegExp (r.b = Y.test (o.compareDocumentPosition), t = b || Y.test (o.contains)? function (a, b) {var c = 9 === a.nodeType ? a.documentElement: a, d = b && b.parentNode; devuelve a === d ||! (! d || 1! == d.nodeType ||! (c.contains? c.contains (d): a .compareDocumentPosition && 16 & a.compareDocumentPosition (d)))}: function (a, b) {if (b) mientras que (b = b.parentNode) if (b === a) return! (a, b) {if (a === b) devuelve l =! 0,0; var d =! a.compareDocumentPosition-! b.compareDocumentPosition; return d? d: (d = (a.ownerDocument | a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition (a) === d? a === n || a. ownerDocument === v && t (v, a)? - 1: b === n || b.ownerDocument === v && t (v, b)? 1: k? ): Function (a, b) {if (a === b) devuelve l =! 0,0; var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b], si (! e ||!f) devuelve a === n? -1: b === n? 1: e? -1: f? 1: k? I (k, a) -I (k, b): 0; (c = c.parentNode) (c = c.parentNode) g.unshift (c); c = b; mientras que (c = c.parentNode) h.unshift (c) , mientras que (g [d] === h [d]) d ++, regreso d? la (g [d], h [d]): g [d] === v? -1: h [d] = a, b) {ga (a, nulo, nulo, b)}, ga.matchesSelector = función (a, b) { if ((a.ownerDocument || a)! == n && m (a), b = b.replace (S, "= '$ 1']"), c.matchesSelector && p &&! A [b + ""] && (! r | || r.test (b)) && (! q ||! q.test (b))) try {var d = s.call (a, b), si (d || c.disconnectedMatch || a. (a, b) () () () () () () () () () () () (a.ownerDocument || a)! == n && m (a), t (a, b)}, ga.attr = función (a, b) {(a.ownerDocument || a)! == n && m (a) ; var e = d.attrHandle [b.toLowerCase ()], f = e && C.call (d.attrHandle, b.toLowerCase ())? e (a, b, p): void 0; return void 0! == f? f: c.attributes ||! p? a.getAttribute (b) :( f = a.getAttributeNode (b)) && f.specified? f.value: null}, ga.escape = función (a) {return (a + ""). {throw new Error ("Error de sintaxis, expresión no reconocida:" + a)}, ga.uniqueSort = función (a) {var b, d = [], e = 0, f = 0; if (l = c. () () () () () () () () () () () () b = ), mientras que (e -) apliegue (d [e], 1)} retorno k = nulo, a}, e = ga.getText = función (a) {var b, c = 0, f = a.nodeType; if (f) {if (1 === f || 9 === f || 11 === f) {if ("string" == typeof a.textContent) devuelve un c + = e (a)} else if (3 === f || 4 === f) return a.nodeValue} else mientras que ( d = ga.selectors = {cacheLength: 50, createPseudo: ia, match: b = a [d ++]{:: {Dir: "parentNode"}, "+": {dir: "parentNode", en primer lugar: PreFilter: {ATTR: function (a) {return a [1] = a [1] .replace (_, aa) , a [3] = (a [3] || a [4] || a [5] || ""). reemplazar (_, aa), "~ =" === a [2] && [3] = "" + a [3] + ""), a.slice (0,4)}, CHILD: function (a) {return a [1] = a [1] .toLowerCase () a [1] .slice (0,3)? (a [3] || ga.error (a [0]), a [4] = + (a [4]? a [5] + (a [6] || 1): 2 * ("even" === a [3] || "odd" === a [3] a [8] || "impar" === a [3])): a [3] && ga.error (a [0]), a}, PSEUDO: función (a) {var b, c =! a [6] && a [2]; devuelve V.CHILD.test (a [0])? Null: (a [3]? A [2] = a [4] || a [5] || "": c && T .test (c) && (b = g (c,! 0)) &&(b = c.indexOf (")", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c.slice 0, b)), a.slice (0,3))}}, filtro: {TAG: función (a) {var b = a.replace (_, aa) .toLowerCase (); return "*" == = a? function () {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASE: function (a) {var b = y [a + ""] (b = nuevo RegExp ("(^ |" + K + ")" + a + "(+ K +" | $) ")) && y (a, función (a) {return b.test (" string "== typeof a.className && a.className ||" undefined "! = typeof a.getAttribute && a.getAttribute (" class ") ||}}}), ATTR: función (a, b, c) (d) {var e = ga.attr (d, a); return null == e? "! =" === b:! b || (e + = "", "=" === b? e === c: "! =" === b? e! == c: "^ =" === b? c && 0 === e.indexOf (c): "* ="=== b? c && e.indexOf (c)> - 1: "$ =" === b? c && e.slice (-c.length) === c: "~ =" === b? (" + e.replace (O, "") + "") .indexOf (c)> - 1: "| =" === b && (e === c || e.slice (0, c.length + 1 ) == a.slice (0,3), g = "last ())),) = = a.slice (-4), h = "of-type" === b; return 1 === d && 0 === e? function (a) {return !! a.parentNode}: function ( b, c, i) {var j, k, l, m, n, o, p = f! == g? "nextSibling": "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase ), s =! i &&! h, t =! 1; si (q) {if (f) {while (p) {m = b; mientras que (m = m [p]) if (h ?.nodeName. toLowerCase () === r: 1 === m.nodeType) return! 1; o = p = "only" === a &&! o && "nextSibling"} return! 0} if (o = [g? q. () (m [u] = {}), es decir,k = l [m.uniqueID] || (l [m.uniqueID] = {}), j = k [a] || [], n = j [0] === w && j [1], t = n && j [2], m = n && q.childNodes [n]; while (1 === m.nodeType && + + t && m === b) {k [a] = [w, n, t]; break}} else if (s && (m = b, l = m [u] k = l [m.uniqueID] || (l [m.uniqueID] = {}), j = k [a] || [], n = j [0] === w && j [1] n), t ===! 1) mientras que (m = ++ n && m && m [p] || (t = n = 0) || o.pop () == r: 1 === m.nodeType) && ++ t && (l = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [ m = uniqueID] = {}), k [a] = [w, t]), m === b)) break; return t = e, t === d || t% d === 0 && t / d> = 0}}}, PSEUDO: function (a, b) {var c, e = d.pseudos [a] || d.setFilters [a.toLowerCase ()] || ga.error ("pseudo no soportado : "+ a); return e [u]? e (b): e.length> 1? (c = [a, a," ", b], d.setFilters.hasOwnProperty (a.(a, c) {var d, f = e (a, b), g = f.length, mientras que (g -) d = I (a, f [g]), (a) () () () () () () () () () () () () () a) {var b = [], c = [], d = h (a.replace (P, "$ 1")) f, g = d (a, nulo, e, []), h = a.length, mientras que (h-) (f = g [h] f)))): función (a, e, f) {retorno b [0] = a, d (b, nulo, f, c), b [0] = null,! c.pop () , tiene: ia (función (a) {función de retorno (b) {return ga (a, b) .length> 0}}), contiene: ia (función a) {return a = a.replace (_, aa ), función (b) {return (b.textContent || b.innerText || e (b)). indexOf (a)> - 1}}) a = a.replace (_, aa) .toLowerCase (), función (b) {var c; do si (c = p ? b.lang: b.getAttribute ("xml: lang") || b.getAttribute ("lang")) devuelve c = c.toLowerCase (), c === a || 0 === c.indexOf (a + "-"), mientras que ((b = b.parentNode) && 1 === b.nodeType); return! 1}}), target: function (b) {var c = a.location && a.location.hash ; devuelve c && c.slice (1) === b.id}, raíz: function (a) {return a === o}, focus: function (a) {return a === n.activeElement && (! n. hasFocus || n.hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)}, habilitado: oa (! 1), disabled: oa (! 0), checked: function a) {var b = a.nodeName.toLowerCase (); return "input" === b && !! a.checked || "option" === b && !! a.selected}, seleccionado: function (a) { return a.parentNode && a.parentNode.selectedIndex, a.selected ===! 0}, empty: function (a) {for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType <6) (a) {return X.test (a.nodeName)}, entrada: function (a) {return! d.pseudos.empty (a)}, a) {return W.test (a.nodeName)}, botón:(a) {var b = a.nodeName.toLowerCase (); return "input" === b && "button" === a.type || "button" === b}, text: function (a) {b var = return = "input" === a.nodeName.toLowerCase () && "text" === a.type && (null == (b = a.getAttribute ("type")) == b.toLowerCase ())}, en primer lugar: pa (function () {return [0]}), last: pa (function (a, b) {return [b-1]}) (a, b, c) {return [c <0? c + b: c]}), incluso: pa (función (a, b) (a, b) {for (var c = 1; c <b; c + = 2) a.push (c), return a}), lt : pa (función (a, b, c) {para (var d = c <0? c + b: c; - d> = 0;) a.push (d) (función (a, b, c) {para (var d = c <0? c + b: c; ++ d <b;) a.push (d), retorno a}}}}, d.pseudos. nth = d.pseudos.eq; para (b en {radio:! 0, casilla de verificación:! 0, archivo:! 0, contraseña:! 0, imagen: | 0}) d.pseudos [b] = ma b) ; para (b en {submit:! 0,restablecer:! 0}) d.pseudos [b] = na (b); función ra () {} ra.prototype = d.filters = d.pseudos, d.setFilters = new ra, g = ga.tokenize = function (a, b) (k) devolver b? 0: k.slice (0), h = a, i = [], j = d.preFilter, mientras que (h) (e = Q.exec (h)) || (e && (h = h.slice (e [0] .length) , i.push (f = [])), c =! 1, (e = R.exec (h)) && (c = e.shift (), f.push ({valor: c, 0] .replace (P, "")}, h = h.slice (c.length)), para (g en d.filter)! (E = V [g] .exec (h)) || j (e = j [g] (e)) || (c = e.shift (), f.push ({valor: c, tipo: g, coincidencias: e}), h = h. sl (c.length)), si (c) break} return b? h.length: h? ga.error (a): z (a, i) .slice (0) d = función a (b, c, b = c, d = b, c = b) (b, c, e) (mientras que (b = b), (b = b) [d]) si (1 === b.{1}: función (b, c, i) {var j, k, l, m = [w, h], si (i) {while (b = b [d]) if (1 === b.nodeType || g) && a (b, c, i)) return! = b.nodeType || g) if (l = b [u] || (b [u] = {}), k = l [b.uniqueID] || (l [b.uniqueID] = {}), e && e === b.nodeName.toLowerCase ()) b = b [d] || b; else {if (j = k [f]) ​​&& j [0] === w && j [1] === h) (2) = m (2) = a (b, c, i)) return! 0} return! 1}} función ua (a) {return (b, c, d)) (var, = a.length), mientras que (e -) si (! a [e] (b, c, d)) return! }: a [0]} función va (a, b, c) {para (var d = 0, e = b.length; d <e; d ++) ga (a, b [d], c) } función wa (a, b, c, d, e) {para (var f, g = [], h = 0, i = a.length, j = null! = a [h]) && (c &&! c (f, d, e) || (g.push (f), j && b.push (h) , e, f) (e = xa (e, f)), (d =(f, g, h, i) {var j, k, l, m = [], n = [], o = g.length, p = f || va (b || "*", h.nodeType [h]: h, []), q = | a ||! f && b? p: wa (p, m, a, h, i) (d, j), d (d, j, d), j, k = j.length, mientras que (k -) (l = j [k]) && (r [n [k]] =! (q [n [k]] = l) (e = a) {if (e) {j = [], k = r.length; mientras que (k-) (l = r [k]) && j.push (q [k] = l) (n, r = [], j, i)} k = r.length, mientras que (k-) (l = r [k] )> - 1 && (f [j] =! (G [j] = l))}} o bien r = wa (r === g? R.splice (o, r.length): r), e? (null, g, r, i): G.apply (g, r)}) función ya (a) {para (var b, c, e, f = a.length, g = d.relative [ 0] .type], h = g || d.relative [""], i = g? 1: 0, k = ta (función (a) l = ta (función (a) {retorno I (b, a)> - 1}, h,! 0), m = [función (a, c, d) {var e =! g && (d || c! == j) || (b = c) .nodeType? k (a, c, d): l (a, c, d)), return b = null, e} (c = d.relative [a [i].(c = d.filter [a [i] .type] .apply (null, a [i] .matches), c [u ) (para e = ++ i; e <f; e ++) si (d.relative [a [e] .type]) break; devuelve xa (i> 1 && ua (m), i> 1 && sa (a.slice (0, i-1) .concat ({value: "" === a [i-2] .type? e && ya (a.slice (i, e)), e <f && ya (a = a.slice (e)), e <f && sa (a)) m.push (c) a, b) {var c = b.length> 0, e = a.length> 0, f = función (f, g, h, i, k) "0", t = f && [], u = [], v = j, x = f || e & d.find.TAG ("*", k), y = w + = null == v? () () () () () () () () () () () () () () () ), si (q (l, 0), (q = a [o ++]) si {e = g || n, h)) {i.push (l); ruptura} k && (w = y)} c && ((l =! q && l) &&(q, b) (), () () () () () () () () () (f) {if (r> 0) mientras que (s -) t [s] || u [s] || (u [s] = E.call (i) (i), k &&! f && u.length> 0 && r + b.length> 1 && ga.uniqueSort (i)} regresar k && (w = y, j = v) f} return h = ga.compile = function (a, b) {bcc, d = [], e = [], f = A [a + g (a)), c = b.length, mientras que (c -) f = ya (b [c]), f [u]? d.push (f): e.push (a, za (e, d)), f.selector = a} regreso f}, i = ga.select = función (a, b, c, e) {var f, i, j, k, l, m = "function" == typeof a && a, n =! e && g (a = m.selector || a); if (c = c || [], 1 === n.length) {if (i = n [0 ] = n [0] .slice (0), i.length> 2 && "ID" === (j = i [0]). {if (b = (d.find.ID (j.matches [0] .replace (_, aa), b) || []) [0] ,! b) devuelve c; m && (b = b.(=) () () () () () () () () () () j = f], d.relative [k = j.type]) break, si ((l = d.find [k]) && (e = l (j.matches [0] .replace (_, aa), $. (i [0] .type) && qa (b.parentNode) || b))) if {i.splice (f, 1), a = e.length && sa (i) c, e), c; break}}} return (m || h (a, n)) (e, b,! p, c,! b || $ .test (a) && qa (b.parentNode) | b), c}, c.sortStable = u.split (""). sort (B) .join ("") === u, c.detectDuplicates = !! l, m (), c.sortDetached = ja (function (a) {return a.innerHTML = "<a href='#'> </a>" , "#" === a.firstChild.getAttribute ("href")}) || ka ("tipo | href | altura | anchura", función (a, b, c) {if (! c) devuelve a. getAttribute (b, "type" === b.toLowerCase ()? 1:2)), c.attributes && ja (function (a) {return a.innerHTML = "<input />", a.firstChild.setAttribute ("value", ""), "" === a.firstChild.getAttribute ("valor")) || ka ("valor", función (a, b, c) {if (! c && "input" === a.nodeName.toLowerCase ()) return a.defaultValue} (función (a) {return null == a.getAttribute ("disabled")}) || ka (J, función (a, b, c) =? 0? B.toLowerCase () :( d = a.getAttributeNode (b)) && d.specified? D.value: null}), ga} (a); r.find = x, r.expr = x. selectores, r.expr [":"] = r.expr.pseudos, r.uniqueSort = r.unique = x.uniqueSort, r.text = x.getText, r.isXMLDoc = x.isXML, r.contains = x .contains, r.escapeSelector = x.escape; var y = función (a, b, c) {var d = [], e = void 0! == c; mientras que ((a = a [b]) && 9! == a.nodeType) if (1 === a.nodeType) {if (e && r (a) .is (c)) break; d.(a)} return d}, z = función (a, b) {para (var c = []; a = a.nextSibling) 1 === a.nodeType && a! == b && c.push (a) ; devuelve c}, A = r.expr.match.needsContext; la función B (a, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()} var C = / ^ <([ az] [^ \ / \ 0]: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> | ) $ / i, D = / ^. [^: # \ [\.,] * $ /; función E (a, b, c) {return r.isFunción (b)? r.grep a, d) {return !! b.call (a, d, a)! == c}): b.nodeType? r.grep (a, función (a) {return a === b! == c }): "string"! = typeof b? r.grep (a, función (a) {return i.call (b, a)> - 1! == c}): D.test (b)? r. filtro (b, a, c) :( b = r.filtro (b, a), r.grep (a, función (a) {return i.call (b, a)> - 1! == c && 1 == = a.nodeType}))} r.filter = función (a, b, c) {var d = b [0]; return c && (a = ": not (" + a + ") b.length && 1 === d.nodeType? r.find.matchesSelector (d, a)? [d]: []: r.find.(b, function (a) {return 1 === a.nodeType}))}, r.fn.extend ({find: función (a) {var b, c, d = this () () () () () () () () () () () () () () () () () (e [b], esto)) return) para (c = this.pushStack ([]), b = 0; b <d; b ++) r.find (a, e [b], c ) () () () () () () () () () () () () () () () () (1) ) {return this.pushStack (E (this, a || [],! 0))}, es: function (a) {return !! E (this, "string" == typeof a && A.test (a)? r (a): a || [], | 1) .length}}), var F, G = / ^ (?: \ s * (<[W] (a, b, c) {var e, f; si (! a) devuelve esto; si (c = c || F, "cadena" == tipo de a) {if (e = "<" === a [0] && ">" === a [a.length-1] && a.length> = 3? [Null, a, nulo]: G.exec (a), | e ||! e [1] && b) return! b || b.jquery? (b || c) .find (a): this.constructor (b) .find (a); if (e [1]) {if (b = b instanceof r? b [0]: b, r (esto es, r.parseHTML (e [1], b && b.nodeType? b.ownerDocument || b: d,! 0)), C.test (e [1]) && r.isPlainObject (b)) para ( e in b) r.isFunction (this [e]) this [e] (b [e]): this.attr (e, b [e]); devuelve esto} return f = d.getElementById (e [2 ], f && (this [0] = f, this.length = 1), esto} return a.nodeType? (this [0] = a, this.length = 1, this): r.isFunction (a)? void 0! == c.ready? c.ready (a): a (r): r.makeArray (a, this)}, H.prototype = r.fn, F = r (d) ^ (?: padres | prev (?: Until | All)) /, J = {children:! 0, contents:! 0, next:! 0, prev: | 0}; r.fn.extend ({has: (a) {var b = r (a, esto), c = b.length; devuelve this.filter (function () {for (var a = 0; a <c; a ++) if (r.contains , b [a])) return, 0)), más cercano: function (a, b) {var c, d = 0, e = this.length, f = [], g = "string"! (a), si (! A.test (a)) para (; d <e;d ++) for (c = this [d]; c && c! == b; c = c.parentNode) if (c.nodeType <11 && (g? g.index (c)> - 1: 1 === c.nodeType && r (f, f): f)}, índice: función (a) {f.p.susc. (c, a) (a), esto [0]): i.call (esto, a.jquery? a [0]: a): este [0] && este [ 0] .parentNode? This.first (). PrevAll (). Length: -1}, agrega: function (a, b) {return this.pushStack (r.uniqueSort (r.merge (this.get () (a, b))))}, addBack: function (a) {return this.add (null == a? this.prevObject: this.prevObject.filter (a))}}) ) {while ((a = a [b]) && 1! == a.nodeType); return a} r.each ({parent: function (a) {var b = a.parentNode; return b && 11! == b. nodeType? b: null}, padres: function (a) {return y (a, "parentNode")}, parentsUntil: function (a, b, c) :(a) {return K (a, "nextSibling")}, prev: function (a) {return K (a, "previousSibling")}, nextAll: }, prevAll: function (a) {return y (a, "previousSibling")}, nextUntil: function (a, b, c) a) {return z ((a.parentNode || {}) first, a)}, children: function (a) {return z (a.firstChild)}, contenido: function (a) {return B (a, "iframe")? a.contentDocument: (B (a, "template") && (a = a.content || a ), función (a, b) {r.fn [a] = función (c, d) {var e = r.map (esto, b, c ), return "Until"! == a.slice (-5) && (d = c), d && "string" == typeof d && (e = r.filter (d, e) J [a] || r.uniqueSort (e), I.test (a) &y e.reverse ()), this.pushStack (e)}); var L = / [^ \ x20 \ t \ r \ n \ f] + / g; función M (a) {var b = {}; (a) (a) (a) (a) (a) (a) (b) = tipo de un M (a): r.extend ({}, a); var b, c, d, e, f = [], g = [], h = -1, i = function () (e = e || a.once, d = b = | 0; g.length; h = -1) {c = g.shift (), mientras que (++ h <f.length) f [h]. aplicar (c [0], c [1]) ===! 1 && a.stopOnFalse && (h = f.length, c =! 1)} a.memory || (c =! 1), b =! 1, e && (f = c? []: "")}, j = {add: function () {return f && (c &&! b && (h = f.length-1, g.push (c) (c): c && c.length && "string"! == r.type () () () devuelve r.each (argumentos, función (a, b) {var c; mientras que ((c) c = r.inArray (b, f, c))> - 1) f.(a, f)> - 1: f.length> 0}, vacío: () {return f && (f = []), this}, disable: function () {return e = g = [], f = c = , lock: function () {return e = g = [], c || b || (f = c = ""), , c) (c = c || [], c = [a, c.slice? c.slice (): c], g.push (c), b || i ()), esto}, fuego: function () {return j.fireWith (this, arguments), this}, despedido: function () {return | d}}; return j}; function N (a) {return a} function O (a) {throw a} función P (a, b, c, d) {var y; try {a && r.isFunction (e = a.promise)? e.call (a) .done (b) .fail ): a && r.isFunction (e = a.then)? e.call (a, b, c): b.apply (void 0, [a] .slice (d) void 0, [a])} r.extend ({Diferido: función (b) {var c = [["notify", "progreso", r.Callbacks ("memoria "), r.Callbacks (" memoria "), 2, [" resolver "," hecho ", r.Callbacks (" una vez memoria "), ("una vez memoria"), d = "pendiente", e = {estado: function () {return d}, siempre: function () {return f.done (argumentos) .fail (argumentos), this}, "catch": function (a) {return e.then (null, a)}, (función [b] {r.each (c, función (c, d) {var e = r.isFunción (a [d [4]]) && a [d [1]] (función () {var a = e & e.apply (esto, argumentos); a && r.isFunction (a.promise)? a.promise (). progreso (b. notificar) .done (b.resolve) .fail (b.reject): b [d [0] + "Con"] (esto, e? [a]: argumentos})}), a = null}). promise ()}, entonces:función (b, d, e) {var f = 0; función g (b, c, d, e) {función de retorno () {var h = esto, i = argumentos, j = función () ; if (! (b <f)) {if (a = d.apply (h, i), a === c.promise ()) throw new TypeError "objeto" == tipo de una "función" == tipo de a) && a.then, r.isFunction (j)? e? j.call (a, g (f, c, N, e), g , c, O, e)): (f, c, N, e), g (f, c, O, e), g (f, c, N, c. (h = 0, i = [a]), (e || c.resolveWith) (h, i))}}, k = e? j: function () {try {j ()} catch (a) {r.Deferred.exceptionHook && r.Deferred.exceptionHook (a, k.stackTrace), b + 1> = f && (d! == O && (h = void 0, i = a]), c.rejectWith (h, i))}; b? k () :( r.Deferred.getStackHook && (k.stackTrace = r.Deferred.getStackHook ()), a.setTimeout (k))} } return r.Deferred (función (a) {c [0] [3] .add (g (0, a, r.isFunción (e)? e: N, a.notifyWith)), c [1] [3 ] .add (g (0, a, r.Función (b)? b: N)), c [2] [3] .add (g (0, a, r.isFunción (d)? d: O) (a) {return null! = a? r.extend (a, e): e}}, f = {} h = b [5]; e [b [1]] = g.add, h && g.add (función () {d = h}, c [3-a] [2] .disable, c [0] [2 ), f [b [0]] = function () {return f [b [0] + "With"] (esto === f? void 0 : this, arguments), this}, f [b [0] + "With"] = g.fireWith}, e.promise (f), b && b.call (f, f), f} (c), e = f.call (argumentos), g = r.Deferrado (), h = función (a) {función de retorno (c) {d [a] = this, e [a] = arguments.length> 1? f.call (argumentos): c, - b || g.resolveWith (d, e)}} if (b <= 1 && (P (a, g.done (h (c)) resolver, g.reject,! B), "pendiente" === g.state () || r.isFunction (e [c] && e [c] () () () () () () () () () () () () c)var Q = / ^ (Eval | Interno | Rango | Referencia | Sintaxis | Tipo | URI) Error $ /; r.Deferred.exceptionHook = función (b, c) {a.console && a.console.warn && b && Q.test (b.name ) && a.console.warn ("excepción jQuery.Deferred:" + b.message, b.stack, c)}, r.readyException = función (b) {a.setTimeout (function () {throw b})}; (R) = r.Deferred (); r.fn.ready = function (a) {return R.then (a) ["catch"] (función (a) {r.readyException (a)}) r.extend ({isReady:! 1, readyWait: 1, listo: function (a) {(a ===! 0? - r.readyWait: r.isReady) || (r.isReady =! 0, a RespuestaResolveWith (d, [r]))}}), r.ready.then = R.then; function S () {d.removeEventListener ("DOMContentLoaded ", S),consola.warn ("excepción jQuery.Deferred:" + b.message, b.stack, c)}, r.readyException = función (b) {a.setTimeout (función () {throw b}}} var R = r.Deferred (); r.fn.ready = function (a) {return R.then (a) ["catch"] (función (a) {r.readyException (a)}), this}, r.extend ({isReady:! 1, readyWait: 1, listo: function (a) {(a ===! 0? - r.readyWait: r.isReady) || (r.isReady =! 0, a! == (), R.ready.then = R.then; function S () {d.removeEventListener ("DOMContentLoaded", S ),consola.warn ("excepción jQuery.Deferred:" + b.message, b.stack, c)}, r.readyException = función (b) {a.setTimeout (función () {throw b}}} var R = r.Deferred (); r.fn.ready = function (a) {return R.then (a) ["catch"] (función (a) {r.readyException (a)}), this}, r.extend ({isReady:! 1, readyWait: 1, listo: function (a) {(a ===! 0? - r.readyWait: r.isReady) || (r.isReady =! 0, a! == (), R.ready.then = R.then; function S () {d.removeEventListener ("DOMContentLoaded", S ),==! 0 && - r.readyWait> 0 || R.resolveWith (d, [r]))}}), r.ready.then = R.then; function S () {d.removeEventListener ("DOMContentLoaded" , S),==! 0 && - r.readyWait> 0 || R.resolveWith (d, [r]))}}), r.ready.then = R.then; function S () {d.removeEventListener ("DOMContentLoaded" , S),
a.removeEventListener ("carga", S), r.ready ()} "complete" === d.readyState || "loading"! == d.readyState &&! d.documentElement.doScroll? a.setTimeout (r. () () () () () () () () () () () () () () () {var h = 0, i = a.length, j = null == c; if ("object" === r.type (c) c [h], 0, f, g)} else if (void 0! == d && (e =! 0, r.isFunction (d) || (g =! 0), j && (g? (a, d), b = nulo) :( j = b, b = función (a, b, c) {return j.call (r (a), c)}) h (h), h, b (a [h], c))), (b (a [h], c, g? d: d.call (a): i b (a [0], c): f}, U = función (a) {return 1 === a.nodeType || 9 === a.nodeType ||! + a .nodeType}; function V () {this.expando = r.expando + V.uid ++} V.uid = 1, V.prototype = {cache: función (a) {var b = a [this.expando]; b || (b = {}, U (a) && (a.nodeType? a [this.expando] = b: Object.defineProperty (a, this.expando, {value: b, configurable:! 0}))), b}, set: function (a, b, c) d, e = this.cache (a); if ("string" == typeof b) e [r.camelCase (b)] = c; else para (d en b) e [r.camelCase (d)] = b [d]; return e}, get: función (a, b) {return void 0 === b? this.cache (a): a [this.expando] && a [this.expando] [r.camelCase b)]}, acceso: función (a, b, c) {return void 0 === b || b && "string" == tipo de b && void 0 === c? this.get (a, b) :( this (a, b, c), void 0! == c? c: b)}, remove: function (a, b) {var c, d = a [this.expando] = d) {if (void 0! == b) {Array.isArray (b)? b = b.map (r.camelCase) :( b = r.camelCase (b), b = b en d? ]: b.match (L) || []), c = b.length, mientras que (c-) delete d [b [c]]} (void 0 === b || r.isEmptyObject (d) ) y, (a.nodeType? a [this.expando] = void 0: delete a [this.expando])}}, hasData: function (a) {var b = a [this.expando] = b &V = V nuevo, V = V nuevo, Y = / ^ (?: \ {[\ w \ W] * \} | \ [\ w \ W] * \]) $ /, Z = / [AZ] / g; función $ (a) {return "true" === a || "false"! == a && ("null" === a? Null: a = a + a: Y.test (a)? JSON.parse (a): a)} función _ (a, b, c) {var d; if (void 0 === c && 1 = == a.nodeType) if (d = "data-" + b.replace (Z, "- $ &") toLowerCase (), c = a.getAttribute (d), "string" == typeof c) intentar {c = $ (c)} capturar (e) {} X.set (a, b, c)} else c = void 0; return c} r.extend ({hasData: función (a) {return X. (a, b, c) {return X.access (a, b, c)}, removeData: function (a, b) {X.remove (a, b)}, _ datos: función (a, b, c) {return W.Acceso (a, b, c)}, ), r.fn.extend ({data: function (a, b) {var c, d, e, f = this [0], g = f && f.attributes; if (void 0 === a) this.length && (e = X.get (f), 1 === f.(c -) g [c] && (d = g [c] .name, 0 === d.indexOf (f, "hasDataAttrs")) (d = r.camelCase (d.slice (5)), _ (f, d, e [d]))); wset (f, "hasDataAttrs",! 0)} return e} return "objeto" == typeof a? this.each (function () {X.set (this, a)}): T (esto, función (b) {var c; if (f && void 0 === b ) {if (c = X.get (f, a), void 0! == c) return c; if (c = _ (f, a), void 0! == c) return c} else this.each (function () {X.set (this, a, b)}), nulo, b, arguments.length> 1, null,! 0)}, removeData: function (a) {return this.each ) {X.remove (this, a)})}}), r.extend ({cola: función (a, b, c) {var d; si (a) devuelve b = (b || "fx" + "cola", d = Wget (a, b), c && (! d || Array.isArray (c)? d = W.access (a, b, r.makeArray (c)): d.push (c)), d || []}, dequeue: función (a, b) b = b || "fx"; var c = r.queue (a, b), d = c.length, c.shift (), f = r._queueHooks (a, b), g = function () {r.dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d-) == b && c.unshift ("inprogress"), delete f.stop, e.call (a, g, f)),; d && f && f.empty.fire ()}, _ queueHooks: function (a, b) b + "queueHooks", return W.get (a, c) || ​​W.access (a, c, {empty: r.Callbacks ("once memory" b + "queue", c])}), r.fn.extend ({fila: función (a, b) {var c = 2; a = "fx", c -), arguments.length <c? r.queue (this [0], a): void 0 === b? == c [0] && r.dequeue (this, a)})}, dequeue (esto, a, b); r._queueHooks (this, a), "fx" === a && "inprogress" function (a) {return this.each (function () {r.dequeue (this, a)})}, clearQueue:función (a) {return this.queue (a || "fx", [])}, promesa: función (a, b) {var c, d = 1, e = r.Deferred () g = this.length, h = function () {- d || e.resolveWith (f, [f])}; "string"! = typeof a && (b = a, a = void 0), a = a (f + g), c + w (g +) c = wget (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty.add h) e.promise (b)}}), var aa = / [+ -]? (?: \ d * \. |) ba = nuevo RegExp ("^ (?: ([+ -]) = |) (" + aa + ") ([az%] *) $", "i" , "Izquierda"], da = función (a, b) {return a = b || a, "ninguno" === a.style.display || "" === a.style.display && r .contains (a.ownerDocument, a) && "none" === r.css (a, "display")}, ea = función (a, b, c, d) {var e, f, g = , para (f en b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []);para (f en b) a.style [f] = g [f]; return e}; función fa (a, b, c, d) {var e, f = 1, g = 20, h = d función () {return d.cur ()}: function () {return r.css (a, b, "")}, i = h (), j = c && c [3] || (r.cssNumber [b] k = (r.cssNumber [b] || "px"! == j && + i) && ba.exec (r.css (a, b)), si (k && k [3] j = j || k [3], c = c || [], k = + i || 1; hacer f = f || ".5", k / = f, r. (a, b, k + j), mientras que f (f = h () / i) && 1! == f && - g)} regreso c && (k = + k || + i || 0 , e = c [1]? k + (c [1] +1) * c [2]: + c [2], d && (d.unit = j, d.start = k, d.end = e) , e} var ga = {}; función ha (a) {var b, c = a.documento propietario, d = a.nodeName, e = ga [d]; return e? e: (b = c.body.appendChild (c.createElement (d)), e = r.css (b, "display"), b.parentNode.removeChild (b), "ninguno" === e && (e = "block"), ga [d] = e, e)} función ia (a, b) {para (var c, d, e = [], f = 0, g = a.length; f <g; f ++) d = a [f], d .style && (c = d.style.display, b? ("none" === c && (e [f] = Wget (d, "display") || null, e [f] || (d.style = "==" = "=" none = "=" = "=" none = ", Wset (d," display ", c))), para (f = 0; f <g; f ++) null! = E [f] && (a [f] .style.display = e [f () {return ia (this)}, toggle: function (a) {return "boolean" == typeof a? a? this.show (): this.hide (): this.each (function () {da (this)? r (this) .show (): r (this) .hide ()})}); var ja = / ^ (?: casilla de verificación | radio) $ / i, ka = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ +) / i, la = / ^ $ | \ / (?: java | ecma) script / i, ma = {opción: [1, "<multiple múltiple"> "," </ select> "] , thead: [1, "<table>", "</ table>"], col: [2," <table> <colgroup> "," </ colgroup> </ table> "], tr: table> "], td: [3," <table> <tbody> <tr> "," </ tr> </ tbody> </ table> ; ma.optgroup = ma.option, ma.tbody = ma.tfoot = ma.colgroup = ma.caption = ma.thead, ma.th = ma.td; función na (a, b) {var c; return c = "undefined"! = typeof a.getElementsByTagName? a.getElementsByTagName (b || "*"): "undefined"! = typeof a.querySelectorAll? a.querySelectorAll (b || "*"): [], void 0 === b || b && B (a, b)? r.merge ([a], c): c} función oa (a, b) {para (var c = 0, d = a.length; c <d ; c ++) W.set (a [c], "globalEval",! b || Wget (b [c], "globalEval"))} var pa = qa (a, b, c, d,e) {para (var f, g, h, i, j, k, l = b.createDocumentFragment (), m = [], n = 0, o = a.length; n <o; = a [n], f || 0 === f) if ("objeto" === r.type (f)) r.merge (m, f.nodeType? [f]: f) pa.test (f)) {g = g || l.appendChild (b.createElement ("div")), h = (ka.exec (f) || ["", ""]) [1]. (), i = ma [h] || ma._default, g.innerHTML = i [1] + r.htmlPrefilter (f) + i [2], k = i [0] g = g.lastChild; r.merge (m, g.childNodes), g = l.firstChild, g.textContent = ""} else m.push (b.createTextNode (f)); l.textContent = "" n = 0, mientras que si (j = r.contains (f.ownerDocument, f), si (f = m [n ++]) si (d && r.inArray (f, d) g = na (l.appendChild (f), "script"), j && oa (g), c) {k = 0, mientras que (f = g [k ++]) la.test (f.type || " .push (f)} return l}! function () {var a = d.createDocumentFragment (), b = a.appendChild (d.createElement ("d.createElement ("input"), c.setAttribute ("type", "radio"), c.setAttribute ("checked", "checked"), c.setAttribute ("name", " "t"),b.appendChild (c), o.checkClone = b.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, b.innerHTML = "<textarea> x </ textarea>", o.noCloneChecked = !! b.cloneNode (! 0) .lastChild.defaultValue} (); var ra = d.documentElement, sa = / ^ key /, ta = / ^ (?: mouse | pointer | contextmenu | () () () (): () función de función () () d.activeElement} catch (a) {}} función ya (a, b, c, d, e, f) {var g, h; if ("object" == typeof b) (d = d || c, c = nulo 0), para (h en b) ya (a, h, c, d, b [h], f) (e = c, d = c = void 0): null == e && ("string" == tipo de c? (e = d, d = void 0) 0)), e ===! 1) e = wa; else if (! E) devuelve a; return 1 === f && (g = e, e = function (a) ), g.apply (esto, argumentos)}, e.guid = g.guid || (g.guid = r.guid ++)), a.cada una de las funciones (a, b, c, d, e) {r.event.add (this, b, e, d, c) var, f, g, h, i, j, k, l, m, n, o, p, q = Wget (a), si (q) {c.handler && (f = c, c = f.handler) , e = f.selector), e && r.find.matchesSelector (ra, e), c.guid || (c.guid = r.guid ++), (i = q.events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = función (b) {return "undefined"! = tipo de r && r.event.triggered! == b.type? r.event.dispatch. (a, argumentos): void 0}), b = (b || ""). coincidencia (L) || [""], j = b.length, mientras que (j-) h = ua.exec (b [j])], n = p = h [1], o = (h [2] || ""). split (".") sort (), n && (l = r. event.special [n] || {}, n = (e? l.delegateType: l.bindType) || n, l = r.event.special [n] || {}, k = r.extend ({ tipo: n, origType: p, datos: d, manejador: c, guid: c.guid, selector: e, needsContext: e && r.expr.match.needsContext.test (e), namespace: o.join (". )},F),(m = i [n]) || (m = i [n] = [], m.delegateCount = 0, l.setup && l.setup.call (a, d, o, g)! a.addEventListener && a.addEventListener (n, g)), l.add && (l.add.call (a, k), k.handler.guid || (k.handler.guid = c.guid)), e? m .splice (m.delegateCount ++, 0, k): m.push (k), r.event.global [n] =! 0)}}, quitar: function (a, b, c, d, e) h, i, j, k, l, m, n, o, p, q = W.hasData (a) && Wget (a), if (q && (i = q.events) j = b.length, mientras que (j -) si (h = ua.exec (b [j]) || [], n = p = h [1], o = (h [2] || ""). split ("."). , n = (d? ldelegateType: l.bindType) || n, m = i [n] || [], h = h [2] && new RegExp ("(^ | \\.)" + o. ), g = f = m.length, mientras que (f -) k = m [f] ,! e && p! == k.origType || c && c.guid! == k.guid || h &&! h.test (k.namespace) || d && d! == k.selector && ("**"! == d ||! k.selector) || (m.splice (f, 1), k.selector && m.delegateCount-, l.remove && l.remove.call (a, k)) 1 || r.removeEvent (a, n, q.handle), delete i [n])}; g &&! m.length && (l.teardown && l.teardown.call (a, o, q.handle)! else para (n en i) r.event.remove (a, n + b [j], c, d,! 0); r.isEmptyObject (i) && W.remove (a, "handle events")}}, (Argumentos), j = (W.get (esto, es decir, "eventos") || {}) [b.type] || [], k = r.event.special [b.type] || {}; para (i [0] = b, c = 1; c <arguments.length; c ++) i [c] = argumentos [c]; if (b.delegateTarget = this,! k.preDispatch || k.preDispatch.call (this, b)! ==! 1) {h = r.event.handlers.call (esto, b, j), c = 0; mientras que ((f = h [c ++]) &&! b.isPropagationStopped ()) {b.currentTarget = f.elem, d = 0; mientras que ((g = f.handlers [d ++]) &&! b.isImmediatePropagationStopped ()) b.rnamespace &&! b.rnamespace.test (g.namespace) || (b.handleObj = g, b.data = g.data, e = ((r.event.special [g.origType] | (b.result = e) ===! 1 && (b.preventDefault (), b.stopPropagation ()) .apply (f.elem, i), void 0! == e & (),}),}}}}}}}}}}}} i = b.legateCount, j = a.target; if (i && j.nodeType &&! ("click" === a.type && a.button> = 1)) for (; j! == this; j = j.parentNode | () () () () () () () () () para (f = [], g = {}, c = 0 (c, c) d = b [c], e = d.selector + "", void 0 === g [e] && (g [e] = d.needsContext? r (e, this) .index (j)> - 1: r.find (e, this, null, [j]). length), g [e] && f.push (d); f.length && h.push ({elem: j, handlers:f})} return j = this, i <b.length && h.push ({elem: j, manejadores: b.slice (i)}), h}, addProp: function (a, b) {Object.defineProperty .Event.prototype, a, {enumerable:! 0, configurable:! 0, get: r.isFunction (b)? Function () {if (this.originalEvent) devuelve b (this.originalEvent)}: function () if (this.originalEvent) devuelve this.originalEvent [a]}, set: function (b) {Object.defineProperty (this, a, {enumerable:! 0, configurable:! 0, ): {function: function {a) {return a [r.expando]? a: new r.Event (a)}, special: {load: {noBubble:! 0}, focus: {trigger: function () {if (this! == xa () && this.focus) devuelve this.focus (),! 1}, delegateType: "focusin"}, blur: {trigger: function () {if (this === xa () && this.blur) return this.blur () ,! 1}, delegateType: "focusout"}, haga clic en: {trigger: function () {if ("checkbox" === this.type && this.click && B (this, entrada")) return this.click (),! 1}, _ defecto: function (a) {return B (a.target, "a")}}, antes de descargar: {postDispatch: function (a) {void 0! == a .result && a.originalEvent && (a.originalEvent.returnValue = a.result)}}}}, r.removeEvent = función (a, b, c) {a.removeEventListener && a.removeEventListener (b, c)}, r.Event = function (a, b) {return this instanceof r.Event? (a && a.type? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a .returnValue ===! 1? va: wa, this.target = a.target && 3 === a.target.nodeType? a.target.parentNode: a.target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget): this.type = a, b && r.extend (esto, b), this.timeStamp = a && a.timeStamp || r.now (), void (this [r.expando] =! 0)): new r.Event (a, b)}, r.Event.prototype = {constructor: r.Event,isDefaultPrevented: wa, isPropagationStopped: wa, isImmediatePropagationStopped: wa, isSimulated:! 1, preventDefault: function () {var a = this.originalEvent; this.isDefaultPrevented = va, a &&! this.isSimulated && a.preventDefault ()}, stopPropagation: function () {var a = this.originalEvent; this.isPropagationStopped = va, a &&! this.isSimulated && a.stopPropagation ()}, stopImmediatePropagation: function () {var a = this.originalEvent; this.isImmediatePropagationStopped = va, a &&! this. isSimulated && a.stopImmediatePropagation (), this.stopPropagation ()}, r.each ({altKey:! 0, bubbles:! 0, cancelable:! 0, changedTouches:! 0, ctrlKey:! 0, detail:! 0, eventPhase : 0, metaKey:! 0, pageX:! 0, pageY:! 0, shiftKey:! 0, view:! 0, "char":! 0, charCode:! 0, key:! 0, keyCode:! , 0: 0: 0: 0: 0: 0: 0: 0:screenY:! 0, targetTouches:! 0, toElement:! 0, toca:! 0, que: function (a) {var b = a.button; return null == a.which && sa.test (a.type)? null ! = a.charCode? a.charCode: a.keyCode:! a.which && void 0! == b && ta.test (a.type)? 1 & b? 1: 2 & b? 3: 4 & b? 2: 0: a.which}} , r.event.addProp), r.each ({mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: pointerover, pointerleave: pointerout}, función (a, b) {r.event.special [a] = {delegateType: b, bindType: b, handle: function (a) {var c, d = this, e = a.relatedTarget, f = a.handleObj; return e && (e === d || r .contains (d, e)) || (a.type = f.origType, c = f.handler.apply (esto, argumentos), a.type = b), c}}}), r.fn.extend (a, b, c, d) {return ya (esto, a, b, c, d)}, una: función (a, b, c, d) b, c, d, 1)}, off: función (a, b, c) {var d, e; si (a && a.preventDefault && a.handleObj) devuelve d = a.handleObj, r (a.delegateTarget) .off (d.namespace? d.origType + "." + d.namespace: d.origType, d.selector, d.handler) () () () () () () () () () () () () () () () e) = b, b = void 0), c ===! 1 && (c = wa), this.each (function () {r.event.remove (this, a, c, b) za = / <(? | area | br | col | embed | hr | img | input | link | meta | param) *) [^>] *) \ /> / gi, Aa = / <script | <estilo | <link / i, Ba = / checked \ s * (?: [^ =] | = \ s * .checked. ) / i, Ca = / ^ true \ / (. *) /, Da = / ^ \ s * <! (?: \ [CDATA \ [| -) | > \ s * $ / g; función Ea (a, b) {retorno B (a, "tabla") && B (11! == b.nodeType? b: b.firstChild, tbody ", a) [0] || a: a} función Fa (a) {return a.type = (null! == a.getAttribute (tipo)) +" / "+ a.type,a} función Ga (a) {var b = Ca.exec (a.type); return b? a.type = b [1]: a.removeAttribute ("type" (1 === b.nodeType) {if (W.hasData (a) && (f = W.Acceso (a), g = Wset (b, f), j = f.events)) {delete g.handle, g.events = {}, para (e en j) para (c = 0, d = j [e] .length; c (d, c ++) r.event.add (b, e, j [e] [c])} X.hasData (a) && (h = X.access (a), i = r.extend , h), X.set (b, i))} función Ia (a, b) {var c = b.nodeName.toLowerCase (); "input" === c && ja.test (a.type)? b .checked = a.checked: "input"! == c && "textarea"! == c || (b.defaultValue = a.defaultValue)} función Ja (a, b, c, d) {b = g.apply ([], b), var, f, h, i, j, k, l = 0, m = a.length, n = m-1, q = b [0] ); if (s || m> 1 && "string" == typeof q &&! o.checkClone && Ba.test (q)) return a.each (función (e) {var f = a.eq [0] = q.call (esto, e, f.() () () () () () () () () () () () () () 1 === e.childNodes.length && (e = f), f || d)) {for (h = r.map (na, script), Fa), i = h.length; l < m, l ++) j = e, l! == n && (j = r.clone (j,! 0,! 0), i && r.merge (h, na a [l], j, l), si (i) para (k = h [h.length-1] .ownerDocument, r.map (h, Ga) (j, "globalEval") && r.contains (k, j) && (j.src? r._evalUrl && r._evalUrl (j .src): p (j.textContent.replace (Da, ""), k))} devuelve una función Ka (a, b, c) {for (var d, e = b? r.filter (b, a): a, f = 0; null! = (d = e [f]); f ++) c || 1! == d.nodeType || r.cleanData (na (d)), d.parentNode && (c && r .contains (d.ownerDocument, d) && oa (na, script)), d.parentNode.removeChild (d)); return a} r.extend ({htmlPrefilter:(a) {return a.replace (za, "<$ 1> </ $ 2>")}, clone: ​​function (a, b, c) {var d, e, f, g, h = a.cloneNode ! 0), i = r.contains (a.ownerDocument, a); if (! (O.noCloneChecked || 1! == a.nodeType && 11! == a.nodeType || r.isXMLDoc (a))) para (g = na (h), f = na (a), d = 0, e = f.length; d <e; d ++) Ia (f [d], g [d] c) para (f = f || na (a), g = g || na (h), d = 0, e = f.length; d <e; ), h}, h}, limpia: función (a, h) ) {for (var b, c, d, e = r.event.special, f = 0; void 0! == (c = a [f] = c [W.expando]) {if (b.events) para (d en b.events) e [d]? r.event.remove (c, d): r.removeEvent (c, d, b.handle) ); c [Wexpando] = void 0} c [X.expando] && (c [X.expando] = void 0)}}}), r.fn.extend ({detach: function (a) Ka (this, a,! 0)}, remove: función (a) {return Ka (this, a)}, texto:función (a) {return T (esto, función (a) {return void 0 === a? r.text (this): this.empty (). each (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = a)})}, nulo, a, arguments.length)}, append: function () {return Ja (this, arguments, function ) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Ea (este, a); b.appendChild (a)}} }, prepend: function () {return Ja (esto, argumentos, función (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = ins (antes) () () {return Ja (this, argumentos, función (a) {this.parentNode && this.parentNode.insertBefore (b, a, this)})}, después: function () {return Ja (this, argumentos, function (a) {this.parentNode && this.parentNode.insertBefore (a, this.nextSibling) para (var a, b = 0; null! = (a = este [b]); b ++) 1 === a.(a, b) {return a = null! = a && a, b = null == b {a) {return T (this, function (a) {var b = this [ 0] || {}, c = 0, d = this.length; if (void 0 === a && 1 === b.nodeType) devuelve b.innerHTML; if ("string" == typeof a &&! Aa.test (a) &&! ma [(ka.exec (a)) [1] .toLowerCase ()]) {a = r.htmlPrefilter (a); try {for (; c < d, c ++) b = esto [c] || {}, 1 === b.nodeType && (r.cleanData (na (b,! 1)), b.innerHTML = a) ) {}} b && this.empty () .adend (a)}, null, a, arguments.length)}, replaceWith: function () {var a = [] var c = this.parentNode; r.inArray (esto, a) <0 && (r.cleanData (na (this)), c && c.replaceChild (b, this))}, r.each ({ appendTo: "(a, b) {r.fn [a] = function (a) {for (var), es decir, c, d = [], e = r (a), f = e.length-1, g = 0; g <= f; g ++) c = g === f? esto: this.clone (! 0) , r (e [g]) [b] (c), h.apply (d, c.get ()), return this.pushStack (d) RegExp ("^ (" + aa + ") (?! px) [az%] + $", "i"), Na = función (b) {var c = b.ownerDocument.defaultView; return c && c.opener || (c = a), c.getComputedStyle (b)}; function () {función b () {if (i) {i.style.cssText = "tamaño de caja: border-box; position: relative; display: ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, = "1%"! == b.top, g = "2px" === b.marginLeft, e = "4px" === b.width, i.style.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, , i = d.createElement ("div"); i.style && (i.style.backgroundClip = "content-box", i.cloneNode (! 0) .style.backgroundClip = "", o.clearCloneStyle = "content- box "=== i.style.backgroundClip, h.style.cssText =" border: 0; width: 8px; height: 0; top: 0; left: -9999px; padding: 0; margin-top: 1px; position : absolute (), h.appendChild (i), r.extend (o, {pixelPosición: función () {return b (), c}, boxSizingReliable: función () {return b (), e}, pixelMarginRight: function ( ) {return b (), f}, reliableMarginLeft: function () {return b (), g}}))} (), función Oa (a, b, c) {var d, e, f, g, h = a.style; return c = c || Na (a), c && (g = c.getPropertyValue (b) || c [b], ""! == g || r.contains (a.ownerDocument, a ) || (g = r.style (a, b)),. o.pixelMarginRight () && Ma.test (g) && La.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0! == g? g + "": g} función Pa (a, b) {return {get: function () {return a ()? void delete this.get: (this.get = b) .apply (esto, argumentos)}}} var Qa = / ^ (none | table (? , "=", "=", "=", "/"), / = Ra, , Ua = ["Webkit", "Moz", "ms"], Va = d.createElement ("div" 0] .toUpperCase () + a.slice (1), c = Ua.length; mientras que (c -) si (a = Ua [c] + b, a en Va) var b = r.cssProps [a]; return b || (b = r.cssProps [a] = Wa (a) || a), b} función Ya (a, b, c) {var d = ba. exec (b), regreso d? Math.(b, c, d, e) {var f, g = (x, d) 0, para (f = c === (d? "Border": "contenido")? 4: "width" === b? 1: 0; f <4; f + = 2) "margin" === c && (g + = r.css (a, c + ca [f] ,! 0, e)), d? f], 0, e)), "margen"! == c && (g- = r.css (a, "frontera" + ca [f] = r.css (a, "relleno" + ca [f] ,! 0, e), "relleno"! == c && (g + = r.css (0, e))); g) función $ a (a, b, c) {var d, e = Na (a), f = Oa (a, b, e) === r.css (a, "boxSizing",! 1, e); return Ma.test (f)? f: (d = g && (o.boxSizingReliable () || f === a.style [ b] ()), f = parseFloat (f) || 0, f + Za (a, b,{}: {opacity: {get: function (a, b) {if (b) {{{{{{{{{{{{{{{ var c = Oa (a, "opacity"); return "=== c?" 1 ": c}}}}, cssNumber: {animationIterationCount:! 0, columnCount:! 0, ! 0, flexShrink:! 0, fontWeight:! 0, lineHeight:! 0, opacity:! 0, order:! 0, orphans:! 0, widows:! 0, zIndex:! 0, zoom:! 0}, cssProps : {"float": "cssFloat"}, style: function (a, b, c, d) {if (a && 3! == a.nodeType && 8! == a.nodeType && a.style) h = r.camelCase (b), i = Ra.test (b), j = a.style; return i || (b = Xa (h)), g = r.cssHooks [b] || r.cssHooks [h], void 0 === c? g && "get" en g && void 0! == (e = g.get (a,! 1, d) "string" === f && (e = ba.exec (c)) && e [1] && (c = fa (a, b, e), n = c && c === c &&("número" === f && (c + = e && e [3] || (r.cssNumber [h]? "": "px")), o.clearCloneStyle || " = b.indexOf ("background") || (j [b] = "inherit"), g && "set" en g && void 0 === (c = g.set (a, c, d) ? j.setProperty (b, c): j [b] = c)), void 0)}}, css: función (a, b, c, d) {var e, f, g, h = r.camelCase (b), i = Ra.test (b), return i || (b = Xa (h)), g = r.cssHooks [b] || r.cssHooks [h], g && "get" en g && e = g.get (a,! 0, c)), void 0 === e && (e = Oa (a, b, d)), (f) = f (f) = f (f) = f (f) = f (f) ["height", "width"], function (a, b) {r.cssHooks [b] = {get: function (a, c, d) {if (c) return! Qa.test (r.css a, "display")) || a.getClientRects (). length && a.getBoundingClientRect ().(a, b, d): ea (a, Sa, function () {return $ a (a, b, d) f = d && Na (a), g = d && Za (a, b, d, "border-box" === r.css (a, "boxSizing",! 1, f) .exec (c)) && "px"! == (e [3] || "px") && (a.style [b] = c, c = r.css (a, b) , c, g)}}}), r.cssHooks.marginLeft = Pa (o.reliableMarginLeft, función (a, b) {if (b) return (parseFloat (Oa (a, "marginLeft")) || a. getBoundingClientRect () left-ea (a, {marginLeft: 0}, function () {return a.getBoundingClientRect () left})) + "px"}), r.each ({margin: "", frontera: "Width"}, función (a, b) {r.cssHooks [a + b] = {expand: function (c) {for (var d = 0, e = {}, f = "== typeof c? c.split (" "): [c]; d <4; d ++) e [a + ca [d] + b] = f [d] || f [d-2] || f [0]; return e}}, La.test (a) || (r.cssHooks [a + b] .set = Ya)}), r.fn.({a, b) {return: T (esto, función (a, b, c) {var d, e, f = {}, g = (d = Na (a), e = b.length; g <e; g ++) f [b [g]] = r.css (a, b [g], | 1, d) void 0! == c? r.style (a, b, c): r.css (a, b)}, a, b, arguments.length> 1) , d, e) {return new _a.prototype.init (a, b, c, d, e)} r.Tween = _a, _a.prototype = {constructor: _a, init: function (a, b, c, d, e, f) {this.elem = a, this.prop = c, this.easing = e || r.easing._default, this.options = b, this.start = this.now = this.cur ), this.end = d, this.unit = f || (r.cssNumber [c]? "": "px")}, cur: function () {var a = _a.propHooks [this.prop]; return a && a.get? a.get (this): _ a.propHooks._default.get (this)}, ejecute: function (a) {var b, c = _a.propHooks [this.prop]; devuelve this.options. duración.del.pos = b = r.easing [this.easing] (a, this.options.duration * a, 0,1, this.options.duration): this.pos = b = a, this.now = (este.end-este.start) * b + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), c && c.set? c.set (this): _ a.propHooks._default.set (this), this}}, a.prototype.init.prototype = _a.prototype, _a.propHooks = {_ default: {get: function (a) {var b; return 1! == a.elem.nodeType || null! = a.elem [a.prop] && null == a.elem.style [a.prop]? a.elem [a.prop] :( b = r.css (a.elem, a.prop, " "), b &&" auto "! == b? b: 0)}, conjunto: function (a) {r.fx.step [a.prop]? r.fx.step [a.prop] (a): 1! == a.elem.nodeType || null == a.elem.style [r.cssProps [a.prop]] &&! R.cssHooks [a.prop]? A.elem [a.prop] = a .now: r.style (a.elem, a.prop, a.now + a.unit)}}}, _ a.propHooks.scrollTop = _a.propHooks.scrollLeft = {set: function (a) {a.elem .nodeType && a.elem.parentNode && (a.elem [a.prop] = a.now)}}, r.easing = {lineal: función (a) {return a}, swing: function (a) Math.cos (a * Math.PI) / 2},_default: "swing"}, r.fx = _a.prototype.init, r.fx.step = {}; var ab, bb, cb = / ^ (?: toggle | show | hide) $ /, db = fileHooks $ /; function eb () {bb && (d.hidden ===! 1 && a.requestAnimationFrame? a.requestAnimationFrame (eb): a.setTimeout (eb, r.fx.interval), r.fx.tick ()) } función fb () {return a.setTimeout (función () (ab = void 0}), ab = r.now ()} función gb (a, b) {var c, d = 0, e = {height: a}, para (b = b? 1: 0; d <4; d + = 2-b) c = ca [d], e ["margen" + c] = e ["relleno" + c] = a; (e.opacity = e.width = a), e} función hb (a, b, c) {para (var d, e = (kb.tweeners [b] || []). (c, b, a)) devuelve d} función ib (a, c, b, a) b, c) {var d, e, f, g, h, i, j, k, l = "anchura" en b || "altura" en b, m = esto, n = {}, o = a. estilo, p = a.nodeType && da (a), q = Wget (a, "fxshow"); c.queue || (g = r.queueHooks (a, "fx"),null == g.unqueued && (g.unqueued = 0, h = g.empty.fire, g.empty.fire = function () {g.unqueued || h ()}), g.unqueued ++, m.always ( function () {m.always (function () {g.unqueued -, r.queue (a, "fx"). length || g.empty.fire ()})}) ) si (e = b [d], cb.test (e)) {if (suprimir b [d], f = f || "toggle" === e, e === (p? () ()) {if} (show) = {e} = |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| .style (a, d)} if (i =! r.isEmptyObject (b), i ||! r.isEmptyObject (n)) {l && 1 === a.nodeType && (c.overflow = [o.overflow, o ,,,,,,,,,,,,,,,,,,,, =, (= a), j = a.style.display || j, k = r.css (a, "display"), ia ([a] === k && null! = j) && (en línea) === k || "inline-block""none" === r.css (a, "float") && (i || (m.done (function () {o.display = j}), null == j && (k = o.display, j = "none" === k? "": k)), o.display = "inline-block")), c.overflow && (o.overflow = "hidden", m.always (function () {o. overflow = c.overflow [0], o.overflowX = c.overflow [1], o.overflowY = c.overflow [2]})), i = | 1; para (d en n) i || (q ? "oculto" en q && (p = q.hidden): q = waccess (a, "fxshow", {display: j}), f && (q.hidden =! p), p && ia ([a] ,! 0), m.done (función () {p || ia ([a]), W.remove (a, "fxshow"), para (d en n) r.style (a, d, n [d] ), i = hb (p? q [d]: 0, d, m), d en q || (q [d] = i.start, p && (i.end = i.start, i. (c, a) si (d = r.camelCase (c), e = b [d], es decir, f = a [c], Array.isArray (f) && (e = f [1], f = a [c] = f [0] [c]), g = r.cssHooks [d],g = "f" = f [c], b [c] = f (c) e)} else b [d] = e} función kb (a, b, c) {var d, e, f = 0, g = kb.prefilters.length, h = r.Deferred () ), i = function () {if (e) return! 1; para (var b = ab || fb (), c = Math.max (0, j.startTime + j.duration (b), d = c / j.duración || 0, f = 1-d, g = 0, i = j.tweens.length; g <i; g ++) j.tweens [g] (h, f, c)), f <1 && i? c: (i || h.notifyWith (a, [j, 1,0]), h.resolveWith (a, [j ), J = h.promise ({elem: a, props: r.extend ({}, b), opts: r.extend (! 0, {specialEasing: {}, easing: r. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:,,,,,,, Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); return j.tweens.push (d), d}, stop: function (b) {var c = 0, d = b? j.tweens.length: 0, si (e) devuelve esto;para (e = 0; c <d; c ++) j.tweens [c] .run (1); return b? (h.notifyWith (a, [j, 1,0]) h.resolveWith (a, [j, b])): h.rejectWith (a, [j, b]), este), k = j.props; para (jb (k, j.opts.specialEasing); f <g; f ++ ) if (d = kb.prefilters [f] .call (j, a, k, j.opts)) devuelve r.isFunction (d.stop) && (r.queueHooks (j.elem, j.opts.queue) .stop = r.proxy (d.stop, d)), d; retorno r.map (k, hb, j), r.isFunción (j.opts.start) && j.opts.start.call (a, j ), j.progress (j.opts.progress) .done (j.opts.done, j.opts.complete) .fail (j.opts.fail) .always (j.opts.always), r.fx. temporizador (r.extend (i, {elem: a, anim: j, cola: j.opts.queue})) j} r.Animation = r.extend (kb, {tweeners: {"*" (a, b) {var c = this.createTween (a, b); devuelve fa (c.elem, a, ba.exec (b), c), c} a = a.match (L), para (var c, d = 0, e = a.length; d <e; d ++) c = a [d], kb.tweeners [c] = kb.tweeners [c] || [], kb.tweeners [c].unshift (b)}, prefilters: [ib], prefilter: function (a, b) {b? kb.prefilters.unshift (a): kb.prefilters.push (a)}}), r.speed = function a, b, c) {var d = a && "object" == typeof a? r.extend ({}, a): {complete: c ||! c && b || r.isFunción (a) && a, , easing: c && b || b &&! r.isFunction (b) && b}; return r.fx.off?d.duration=0:"number"!=typeof d.duration && (d.duration in r.fx.speeds? d.duration = r.fx.speeds [d.duration]: d.duration = r.fx.speeds._default), null! = d.queue && d.queue! ==! 0 || (d.queue = "fx d.old = d.complete, d.complete = function () {r.isFunction (d.old) && d.old.call (this), d.queue && r.dequeue (this, d.queue)}, d}, r.fn.extend ({fadeTo: función (a, b, c, d) {return this.filter (da) .css ("opacity", 0) .show (). end (). animate {opacidad: b}, a, c, d)}, animate: función (a, b, c, d) {var e = r.isEmptyObject (a),f = r.speed (b, c, d), g = función () {var b = kb (esto, r.extend ({}, a), f) finalizar ")) && b.stop (! 0)}; return g.finish = g, e || f.queue ===! 1? this.each (g): this.queue (f.queue, g)} , parada: función (a, b, c) {var d = función (a) {var b = a.stop; borrar a.stop, b (c)}; devolver "string"! = typeof a && (c = b , b = a, a = void 0), b && a! ==! 1 && this.queue (a || "fx", []), this.each a && a + "queueHooks", f = r.timers, g = Wget (this); si (e) g [e] && g [e] .stop && d (g [e] e] && g [e] .stop && db.test (e) && d (g [e]); para (e = f.length; e -;) f [e] .elem! == this || null! = a && f [e] .queue! == a || (f [e] .anim.stop (c), b =! 1, f.splice (e, 1)); b && c || r.dequeue (this, a () () () () () () () () () () () () {}d = c [a + "cola"], e = c [a + "queueHooks"], f = r.timers, g = d? d.length: 0; , a, []), e & e.stop && e.stop.call (this,! 0), b = f.length; b -;) f [b] .elem === this && f [b] .queue === (b = 0; b <g; b ++) d [b] && d [b] .finish && d [b] .call (this); delete c.finish})}), r.each (["toggle", "show", "ocultar"], function (a, b) {var c = r.fn [ b]; r.fn [b] = función (a, d, e) {return null == a || "boolean" == typeof a? c.apply (this, arguments): this.animate (gb ,,,,,,,,,,,,,,,,,,,,,,,,,,,, () opacidad: "show"}, fadeOut: {opacity: "ocultar"}, fadeToggle: {opacity: "toggle"}}, función (a, b) {r.fn [a] = función (a, c, d) {return this.animate (b, a, c,d)}}, r.timers = [], r.fx.tick = function () {var a, b = 0, c = r.timers; para (ab = r.now (); b <c. longitud, b ++) a = c [b], a () || c [b]! == a || c.splice (b -, 1); c.length || r.fx.stop (), ab = void 0}, r.fx.timer = function (a) {r.timers.push (a), r.fx.start ()}, r.fx.interval = 13, r.fx.start = function () {bb || (bb =! 0, eb ())}, r.fx.stop = function () {bb = null}, r.fx.speeds = {lento: 600, rápido: 200, 400}, r.fn.delay = función (b, c) {return b = r.fx? R.fx.speeds [b] || b: b, c = c || "fx", this.queue ( c, función (c, d) {var e = a.setTimeout (c, b); d.stop = function () {a.clearTimeout (e)}})}, function () {var a = d.createElement ("input"), b = d.createElement ("select"), c = b.appendChild (d.createElement ("opción")); a.type = "checkbox", o.checkOn = ""! == a.value, o.optSelected = c.selected, a = d.createElement ("entrada"), a.value = "t", a.type = "radio", o.radioValue = "t"= {a, b} {return T (this, r.attr, a, b, argumentos.length> 1)}, removeAttr: function (a) {return this.each (function () {r.removeAttr (this, a)})}}), r.extend ({attr: function (a, b (3, == f && 8! == f && 2! == f) return "undefined" == tipo de a.getAttribute? r.prop (a, b, c) :( 1 === f && r.isXMLDoc (a) || (e = r.attrHooks [b.toLowerCase ()] || (r.expr.match.bool.test (b)? lb: void 0) ), void 0! == c? null === c? void r.removeAttr (a, b): e && "set" en e && void 0! == (d = e.set (a, c, b))? d: (a.setAttribute (b, c + ""), c): e && "get" en e && null! == (d = e.get (a, b) a, b),cada uno (función () {r.removeAttr (este, a)})}}, r.extend ({attr: función (a, b, c) {var d, e, f = a.nodeType; == f && 2! == f) return "undefined" == typeof a.getAttribute? r.prop (a, b, c) :( 1 === f && r.isXMLDoc (a) || (e = r.attrHooks [b.toLowerCase ()] || (r.expr.match.bool.test (b)? lb: void 0)), void 0! == c? null === c? void r. removeAttr (a, b): e && "set" en e && void 0! == (d = e.set (a, c, b) (d = e.get (a, b))? d: (d = r.find.attr (a, b),cada uno (función () {r.removeAttr (este, a)})}}, r.extend ({attr: función (a, b, c) {var d, e, f = a.nodeType; == f && 2! == f) return "undefined" == typeof a.getAttribute? r.prop (a, b, c) :( 1 === f && r.isXMLDoc (a) || (e = r.attrHooks [b.toLowerCase ()] || (r.expr.match.bool.test (b)? lb: void 0)), void 0! == c? null === c? void r. removeAttr (a, b): e && "set" en e && void 0! == (d = e.set (a, c, b) (d = e.get (a, b))? d: (d = r.find.attr (a, b),removeAttr (a, b): e && "set" en e && void 0! == (d = e.set (a, c, b) (d = e.get (a, b))? d: (d = r.find.attr (a, b),removeAttr (a, b): e && "set" en e && void 0! == (d = e.set (a, c, b) (d = e.get (a, b))? d: (d = r.find.attr (a, b),
(a, b) {if (! o.radioValue && "radio" === b && B (a, "input")) {{{{{{{{{{ var c = a.value; return a.setAttribute ("tipo", b), c && (a.value = c), b}}}}, removeAttr: function (a, b) e = b && b.match (L); if (e && 1 === a.nodeType) while (c = e [d ++]) a.removeAttribute (c) ) {return b ===! 1? r.removeAttr (a, c): a.setAttribute (c, c), c}}, r.each (r.expr.match.bool.source.match (/ \ w + / g), función (a, b) {var c = mb [b] || r.find.attr; mb [b] = función (a, b, d) {var e, f, g = b. (b, d)? g: nulo, mb [g] = f), e }})); var nb = / ^ (?: entrada | seleccione | textarea | botón) $ / i, ob = / ^ (?: a | area) $ / i; r.fn.extend ({prop: function a, b) {return T (this, r.prop, a, b, arguments.length> 1)}, removeProp: function (a) {return this.each (function () {delete this [r.propFix [a ] || a]})}}), r.if (3! == f && 8! == f && 2! == f) return 1 === f && r.isXMLDoc ({prop: function (a, b, c) {var d, e, f = a.nodeType; (d = e.set) (b = r.propFix [b] || b, e = r.propHooks [b]), void 0! == c? e & (a, c, b)) d: a [b] = c: e && "get" en e && null! == (d, {tabIndex: {get: function (a) {var b = r.find.attr (a, "tabindex"); return b? parseInt (b, 10): nb.test (a.nodeName) || ob.test (a.nodeName) && a.href? 0: -1}}}, propFix: {"for": "htmlFor", "class": "className"}}), o.optSelected || (r.propHooks.selected = {get: function (a) {var b = a.parentNode; return b && b.parentNode && b.parentNode.selectedIndex, null}, set: function (a) {var b = a.parentNode; b && (b.selectedIndex, b. parentNode && b.parentNode.selectedIndex)}}), r.each (["[tabIndex "," readOnly "," maxLength "," cellSpacing "," cellPadding "," rowSpan "," colSpan "," useMap "," frameBorder "," contentEditable "], function () {r.propFix [this. (a) {return a.getAttribute && a.getAttribute (a) {a.getAttribute && a.getAttribute ("clase") r.fn.extend ({addClass: función (a) {var b, c, d, e, f, g, h, i = 0; )) return this.each (function (b) {r (this) .addClass (a.call (this, b, qb (this))) (c = this [i ++]) si (e = qb (c), d = 1 === c.nodeType && "" + pb (e) + "") {g = 0, mientras que (f = b [g ++]) d.indexOf ("" + f + "") <0 && (d + = f + ""); h = pb (d), e! == h && c.setAttribute ("class", h)}} devuelve esto}, removeClass: function (a) {var b, c, d, e, f, g, h, i = 0; this.each (function (b) {r (this) .removeClass (a.call (this, b, qb (this))) "), si (" string "== typeof a && a) {b = a.match (L) || [], mientras que (c = este [i ++]) si (e = qb (c), d = 1 == = c.nodeType && "" + pb (e) + "") {g = 0; mientras que (f = b [g ++]) mientras que (d.indexOf ("" + f + "")> - 1) d = d. () (), (), () () () () () () () () () () () h) c = typeof a; return "boolean" == typeof b && "string" === c? b? this.addClass (a): this.removeClass (a): r.isFunction (a)? this.each (function c) {r (this) .toggleClass (a.call (esto, c, qb (este), b), b)}): esto.cada uno (función () {var b, d, e, f; if ("string" === c) {d = 0, e = r (este), f = a.match (L) || []; mientras que (b = f [d ++]) e.hasClass (b)? e.removeClass (b): e.addClass (b)} else void 0! == a && "boolean"! == c || (b = qb (this), b && Wset (this, "__ className __", b), this.setAttribute && this.setAttribute ("class", b || a ===! 1? (c = this [d ++]) if (1 ================================================================================================= " c.nodeType && ("" + pb (qb (c)) + "") .indexOf (b)> - 1) return! 0; return! 1}}); var rb = / \ r / g; r.fn () () () () () () () () () () () () () () {} {var e; 1 === this.nodeType && (e = d? a.call (this, c, r (this) .val ()): a, null == e? = typeof e? e + = "":Array.isArray (e) && (e = r.map (e, función (a) {return null == a? "": A + ""})), b = r.valHooks [this.type] || r .valHooks [this.nodeName.toLowerCase ()], b && "set" en b && void 0! == b.set (this, e, "value") || (this.value = e) ) return b = r.valHooks [e.type] || r.valHooks [e.nodeName.toLowerCase ()], b && "get" en b && void 0! == (c = b.get (e, "value") ) c: (c = e.value, "string" == tipo de c? c.replace (rb, ""): null == c? "": c)}}}), r.extend ({valHooks : {opción: {get: function (a) {var b = r.find.attr (a, "valor"); devuelve null! = b? b: pb (r.text (a))}}, selecciona: {get: function (a) {var b, c, d, e = a.opciones, f = a.selectedIndex, g = "select-one" === a.type, h = g? null: [] i = g? f + 1: e.length, para (d = f <0? i: g? f: 0; d <i; d ++) if (c = e [d], c.selected || d === f) &&! c.disabled && (! c.parentNode.deshabilitado (B) () () () () () () () () () () a, b) {var c, d, e = a.opciones, f = r.makeArray (b), g = e.length; mientras que (g-) d = e [g], (d.selected = r .inArray (r.valHooks.option.get (d), f)> - 1) && (c =! 0); retorno c || (a.selectedIndex = -1), f}}}}), r. () () () () {r.valHooks [this] = {set: función (a, b) {if (Array.isArray (b)) devuelve a.checked = r.inArray (r (a) .val (), b)> - 1}}, o.checkOn || (r.valHooks [this] .get = function (a) {return null === a.getAttribute ("value" )?)))); var sb = / ^ (?: focusinfocus | focusoutblur) $ /; r.extend (r.event, {trigger: función (b, c, e, f) (b, "type")? b.type: b, q = l.call (b, "type")? b, "espacio de nombres")? b.namespace.split ("."): []; if (h = i = e = e || d, 3! == e.nodeType && 8! == e.nodeType &&!sb.test (p + r.event.triggered) && (p.indexOf (".")> - 1 && (q = p.split ("."), p = q.shift (), q.sort () ), k = p.indexOf (":") <0 && "on" + p, b = b [r.expando]? b: nuevo r.Event (p, "object" == typeof b && b), b.isTrigger = f? 2: 3, b.namespace = q.join ("."), b.rnamespace = b.namespace? new RegExp ("(^ | \\.)" + q.join ("\\. ?:. * \\. |) ") +" (\\. | $) "): null, b.result = void 0, b.target || (b.target = e), c = null == c? [b]: r.makeArray (c, [b]), n = r.event.special [p] || {}, f ||! n.trigger || n.trigger.apply (e, c () = (1)) {if (! F &&! N.noBubble &&! R.isWindow (e)) {for (j = n.legateType || p, sb.test (j + p) h.parentNode); h; h = h.parentNode) o.push (h), i = h; i === (e.ownerDocument || d) && o.push (i.defaultView || i.parentWindow || a)} g = 0, mientras que ((h = o [g ++]) &&! b.isPropagationStopped ()) b.type = g> 1? j: n.(h, c), m = (wget (h, "eventos")} k && h [k], m && m.apply && U (h) && (b.result = m.apply (h, c), b.result ===! 1 && b.preventDefault ()); return b.type = p, f || b.isDefaultPrevented () || n._default && n._default.apply (o.pop (), c)! ==! 1 ||! U (e) || k && r.isFunction (e [p]) &&! r. es.window (e) && (i = e [k], i && (e [k] = null), r.event.triggered = p, e [p] (), r.event.triggered = void 0, i && (k) = i)), b.result}}, simular: función (a, b, c) {var d = r.extend (nuevo r.Event, c, {type: a, isSimulated: | 0} (r, null, b)}}, r.fn.extend ({trigger: function (a, b) {return this.each (function () {r.event.trigger (a, b, this)})}, triggerHandler: función (a, b) {var c = este [0], si (c) devuelve r.event.trigger (a, b, c,! 0) .cada("(a, b) {r.fn [b] = función (a, c) La función (a, b) {return arguments.length> 0? this.on (b, null, a, c): this.trigger (b)}}), r.fn.extend ({hover: function (a, b) {return this. mouseenter (a) .mouseleave (b || a)}}, o.focusin = "onfocusin" en una función, o.focusin || r.each ({focus: "focusin", blur: "focusout"} (a, b) {var c = función (a) {r.event.simulate (b, a.target, r.event.fix (a))}; r.event.special [b] = {setup: function () {var d = this.ownerDocument || this, e = W.access (d, b); e || d.addEventListener (a, c,! 0), W.Acceso (d, b, (e | 0) +1)}, desmontaje: function () {var d = this.ownerDocument || this, e = W.access (d, b) -1; e? W. Acceso (d, b, e) (d.removeEventListener (a, c,! 0), W.remove (d, b))}}});var tb = a.location, ub = r.now (), vb = / \? /; r.parseXML = function (b) {var c; if (! b || "string"! = typeof b) return null ; try {c = (nuevo a.DOMParser) .parseFromString (b, "text / xml")} catch (d) {c = void 0} return c &&! c.getElementsByTagName ("parsererror"). error ("XML no válido:" + b), c}; var wb = / \ [\] $ /, xb = / \ r? \ n / g, yb = / ^ () () () () () () () () () () () () () Array (b) (b, función (b, e) {c || wb.test (a)? d (a, e): Ab (a + (b)) d (a, b), o bien para (e en b) (A, b) {var c, d = [], e = función (a, b) { var c = r.isFunción (b)? b (): b; d [d.length] = encodeURIComponent (a) + "="+ encodeURIComponent (null == c? "": c)}; if (Array.isArray (a) || a.jquery &&! r.isPlainObject (a)) r.each (a, function () {e (this. nombre, este valor)}), else para (c en a) Ab (c, a [c], b, e), return d.join ("&")}, r.fn.extend ({serialize: function () {return r.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var a = r.prop (esto, "elements"); .makeArray (a): this}). filter (function () {var a = this.type; devuelve this.name &&! r (this) .is (": disabled") && zb.test (this.nodeName) &&! yb.test (a) && (this.checked ||! ja.test (a))). map (función (a, b) {var c = r (this) .val (); return null == c ? null: Array.isArray (c)? r.map (c, función (a) {return {nombre: b.name, valor: a.replace (xb, "\ r \ n" : b.nombre, valor: c.replace (xb, "\ r \ n")}). get ()}}); var Bb = /% 20 / g, Cb = / #. * $ /, Db = / ([? &] / / / / / / / Eb = / ^ (. *?): [/ T] * ([^ \ r \ n) *) $ / gm, Fb = / ^ / / Gb = / ^ (?: GET | HEAD) $ /, Hb = / ^ \ / \ //, Ib = {}, Jb (B, c) = {}, Kb = "* /" concat ("*"), Lb = d.createElement ("a"); {"string"! = typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase (). match (L) c)) mientras que (d = f [e ++]) "+" === d [0]? (d = d.slice (1) || "*", (a [d] = a [d] || (c)) () () () () () () () () () () () f = a === Jb; función g (h) {var i; return e [h] =! 0, r.each (a [h] || [], función (a, h) {var j = h (b, c, d), return "string"! = tipo de j || f || e [j]? f?! (i = j): void 0: (b.dataTypes.unshift (j), g j), 1)}), i} return g (b.dataTypes [0]) ||! e ["*"] && g ("*") función Ob (a, b) {var c, d, e = r.ajaxSettings.() () () () () () () () () () () () () () , d = a.contents, i = a.dataTypes; mientras que (" * "=== i [0]) i.shift (), void 0 === d && (d = a.mimeType || b.getResponseHeader (" Content-Type ")) h) if (h [e] && h [e] .test (d)) {i.unshift (e); break} if (i [0] en c) f = i [0] c) {if (| i [0] || a.converters [e + "" + i [0]]) {f = e; break} g || (g = e)} f = f || g} if (f) return f! == i [0] && i.unshift (f), c [f]} función Qb (a, b, c, d) }, k = a.dataTypes.slice (); if (k [1]) para (g en a.converters) j [g.toLowerCase ()] = a.converters [g]; f = k.shift () ; mientras que (f) if (a.responseFields [f] && (c [a.responseFields [f]] = b),! i && d && a.dataFilter && (b = a.dataFilter (b, a.dataType) , f = k.shift ()) if ("*" === f) f = i; else if ("*"!= f) {if (g = j [i + "" + f] || j ["*" + f], g) para (e en j) if (h = e.split (" ), h [1] === f && (g = j [i + "" + h [0]] || j ["*" + h [0] j [e]: j [e]! ==! 0 && (f = h [0], k.unshift (h [1])) (b) g (b); b {g = b (b)} b = g (b) f}}} return {estado: "éxito", datos: b}} r.extend ({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: tb.href, , isLocal: Fb.test (tb.protocol), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8" "/ Xml:" application / xml, text / xml ", json:" application / json,text / javascript "}, contenido: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: json: "responseJSON"}, convertidores: {"* text": String, "text html":! 0, "text json": JSON.parse, "text xml": r.parseXML}, flatOptions: {url :! 0, context:! 0}}, ajaxSetup: function (a, b) {return b? Ob (Ob (a, r.ajaxSettings), b): Ob (r.ajaxSettings, a)}, ajaxPrefilter: ), ajaxTransport: Mb (Jb), ajax: función (b, c) {"objeto" == tipo de b && (c = b, b = void 0), c = c || {}; var e, f, g h, i, j, k, l, m, n, o = r.ajaxSetup ({}, c), p = o.context || o, q = o.context && (p.nodeType || p.jquery (r), r = (r), r = (r), r = (r), t = r.Calbacks (una vez memoria), u = o.statusCode || {}, v = , x = "cancelado", y = {readyState: 0, getResponseHeader: función (a) {var b; si (k) {if (! h) {h = {}, mientras que (b = Eb.b) [b] [b] [b] [b] [b] [b] [b] [b] [b] (a = b) {return null == k && (a = w [a.toLowerCase ()] = w [a.toLowerCase ()] || a, v [a] = b), this}, overrideMimeType: function (a) {return null == k && (o.mimeType = a), this}, statusCode: function (a) {var b; (b [a] [b] = [u [b], a [b]], devuelve esto}, abort: function (a) {var b = a | x, return e && e.abort (b), A (0, b), this}}, if (s.promise (y), o.url = ((b || o.url || tb.href) + "") .replace (Hb, tb.protocol + "//"), o.type = c.method || c.type || o.method || o.type, o.dataTypes = (o.dataType || () (), () () () () () () () () toLowerCase () .lugar (L) || [""], null == o.crossDomain) {j = d.createElement .href = j.href, o.crossDomain = Lb.protocol + "//" + Lb.host! = j.protocolo + "//" + j.host} catch (z) {o.crossDomain =! 0}} si (o.data && o.processData && "string"! = typeof o.data && (o.data = r.param (o. datos, o.tradicionales), Nb (Ib, o, c, y), k) retorno y; l = r.event && o.global, l && 0 === r.active ++ && r.event.trigger ("ajaxStart" ), o.type = o.type.toUpperCase (), o.hasContent =! Gb.test (o.type), f = o.url.replace (Cb, ""), o.hasContent? o.data && o. ("bb," + ")): & nbsp; & nbsp; & nbsp; & nbsp; o & lt; = o.url.slice (f.length), o.data && (f + = (vb.test (f)? "&": "?") + o.data, delete o.data), o.cache == =! 1 && (f = f.replace (Db, "$ 1"), n = (vb.test (f)? "&":? f + n), o.ifModified && r.lastModified [f] && y.setRequestHeader ("If-None-Match", r.etag [f] && y.setRequestHeader ("If-Modified-Since" f])), y.setRequestHeader ("Accept", o.dataTypes) [0] & o.accepts [o.dataTypes [0]]? O.accepts [o.dataTypes [0]] + ("*"! == o.dataTypes [0]? "," + Kb + "; q = 0.01 ":" "): o.accepts [" * "]), para (m en o.headers) y.setRequestHeader (m, o.headers [m]), si (o.beforeSend && (o.beforeSend.call (p, y, o) ===! 1 || k)) return y.abort (); si (x = "abortar", t.add (o.complete), y.done (o.success) y.fail (o.error), e = Nb (Jb, o, c, y)) {if (y.readyState = 1, l && q.trigger ("ajaxSend", [y, o]) k) return y o.async && o.timeout> 0 && (i = a.setTimeout (function () {y.abort (timeout)}, o.timeout)); try {k =! 1, e.send (v, A)} catch z) {if (k) throw z, A (-1, z)}} A (b, c, d, h) v, w, x = c; k || (k =! 0, i && a.clearTimeout (i), e = void 0, g = h || "", y.readyState = b> 0? = b> = 200 && b <300 || 304 === b, d && (v = Pb (o, y, d)), v = Qb (o, v, y, j) = y.getResponseHeader, w && (r.lastModified [f] = w), w = y.getResponseHeader ("etag"), w && (r.etag [f] = w) == b ================================================================================================================= " (x = "error", b <0 && (b = 0))), y.status = b, y.statusText = (c || (x, y, x)), y (x, y).statusCode (u), u = void 0, l && q.trigger (j? "ajaxSuccess": "ajaxError", [y, o, j? m: n] l && (q.trigger ("ajaxComplete", [y, o]), - r.active || r.event.trigger ("ajaxStop"))} return y}, getJSON: function (a, b, c ) {return r.get (a, b, c, "json")}, getScript: función (a, b) {return r.get (a, void 0, b, "script")}}, r. (a, b) = función (a, c, d, e) {return r.isFunción (c) && (e = e || d , d = c, c = void 0), r.ajax (r.extend ({url: a, tipo: b, tipo de datos: e, datos: c, éxito: d}, r.isPlainObject (a) && a) }}, r._evalUrl = function (a) {return r.ajax ({url: a, type: "GET", dataType: "script", cache:! 0, async: devuelve esto [0] && (r.isFunction (a) && (a = a.call (this [ 0])),(0) .cone (! 0), este [0] .parentNode && b.insertBefore (este [0]), b.map (function () {var a = this; while (a.firstElementChild) a = a.firstElementChild; devuelve a}). append (this)), this}, wrapInner: function (a) {return r.isFunción (a)? this.each b) {r (this) .wrapInner (a.call (this, b))}): this.each (function () {var b = r (this), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, wrap: función (a) {var b = r.isFunción (a); devuelve this.each (función (c) {r (this) .wrapAll (a) {return this.parent (a) .not ("body"). each (function () {r (this) .replaceWith (this.childNodes)}), esto}}, r.expr.pseudos.hidden = function (a) {return! r.expr.pseudos.visible (a)}, r.expr.pseudos.visible = function (a) {return !! (a.offsetWidth || a.offsetHeight || a.getClientRects (). length)}, r.ajaxSettings.xhr = function () {try {return new a.XMLHttpRequest} catch (b) {}}; var Rb = {0: 200,1223: 204}, Sb = r.ajaxSettings.xhr (); o.cors = !! Sb && "withCredentials" en Sb, o.ajax = Sb = \ r \ sb, r.ajaxTransport (función (b) {var c, d; if (o.cors || Sb &&! B.crossDomain) return {enviar: función (e, f) {var g, h = b .xhr (), if (h.open (b.type, b.url, b.async, b.username, b.password), b.xhrFields) para (g en b.xhrFields) h [g] = b .xhrFields [g]; b.mimeType && h.overrideMimeType && h.overrideMimeType (b.mimeType), b.crossDomain || e ["X-Requested-With"] || (e ["X-Requested-With"] = "XMLHttpRequest () () () () () () () () () () () () () () () () () en la que g = h.onreadystatechange = null, "abort" === a? h.abort (): "error" === a? "number"! = typeof h.status? f (0, error) h.status, h.statusText): f (Rb [h.status] || h.status,h.statusText, "text"! == (h.responseType || "text") || "string"! = tipoof h.responseText? {binario: h.response}: {text: h.responseText}, h. getAllResponseHeaders ()))}, h.onload = c (), d = h.onerror = c ("error"), void 0! == h.onabort? h.onabort = d: h.onreadystatechange = function ) {4 === h.readyState && a.setTimeout (function () {c && d ()})}, c = c ("abortar"); try {h.send (b.hasContent && b.data || null)} catch i) {if (c) throw i}}, abort: function () {c && c ()}}}, r.ajaxPrefilter (function (a) {a.crossDomain && (a.contents.script =! 1)}) , r.ajaxSetup ({acepta: {script: "text / javascript, application / javascript, application / ecmascript, application / x-ecmascript" /}, converters: {"script de texto": function (a) {return r.globalEval (a), a}}}), r.ajaxPrefilter ("script"función (a) {void 0 === a.cache && (a.cache =! 1), a.crossDomain && (a.type = "GET")}, r.ajaxTransport ("script" if (a.crossDomain) {var b, c; return {enviar: función (e, f) {b = r ("<script>"). .on ("error de carga", c = función (a) {b.remove (), c = nulo, a && f ("error" = 404: 200, tipo a. head.appendChild (b [0])}, abort: function () {c && c ()}}}); var Tb = [], Ub = / (=) \? (? = & | $) | \? \? /; r.ajaxSetup (jsonp: "callback", jsonpCallback: function () {var a = Tb.pop () || r.expando + "_" + ub ++; devuelve esto [a] =! 0, a }}, r.ajaxPrefilter ("json jsonp", función (b, c, d) {var e, f, g, h = b.jsonp! ==! 1 && (Ub.test (b.url)? " url ":" cadena "== typeof b.data && 0 === (b.contentType ||" "). indexOf ("(b.data) && "data"); si (h || "jsonp" === b.dataTypes [0]) return e = b.jsonpCallback = r.isFunction (b.jsonpCallback)? b.jsonpCallback (): b.jsonpCallback, h? b [h] = b [h] .replace (Ub, "$ 1" + e): b.jsonp! ==! 1 && (b.url + = (vb.test (b.url)? "&": "?") + b.jsonp + "=" + e), b.converters ["script json"] = function () (= +) no es llamado, g [0], b.dataTypes [0] = "json", f = a [e], a [e] = function () {g = argumentos }, d.always (function () {void 0 === f? r (a) .removeProp (e): a [e] = f, b [e] && (b.jsonpCallback = c.jsonpCallback, Tb. (g), g = f = void 0}), o.createHTMLDocument = function () {var a = d.implementation. createHTMLDocument (""). body; return a.innerHTML = "<(a, b, c) {if ("string"! = typeof a) form </ form> </ form> ", 2 === a.childNodes.length} ) return []; "boolean" == typeof b && (c = b, b =! 1); var e, f, g; return b || (o.createHTMLDocument? (b = d.implementation.createHTMLDocument (" ), e = b.createElement ("base"), e.href = d.location.href, b.head.appendChild (e)): b = d), f = C.exec (a), g =! (), () () () () () () () () () () () () f (), () () () () () () () () () () f = pb (a.slice (h)), a = a.slice (0, h)), r.isFunción (b)? (c = b, b = void 0): b && "object" == typeof b && e = "POST"), g.length> 0 && r.ajax ({url: a, tipo: e || "GET", dataType: "html", data: b}).(a) {f = argumentos, g.html (d? r ("<div>") .adend (r.parseHTML (a) a, b) {g.each (function () {c.apply (this, f || [a.responseText, b, a] ajaxStop "," ajaxComplete "," ajaxError "," ajaxSuccess "," ajaxSend "], función (a, b) {r.fn [b] = función (a) {return this.on (b, a)}} ) r.expr.pseudos.animated = function (a) {return r.grep (r.timers, function (b) {return a === b.elem}) length}, r.offset = {setOffset: función (a, b, c) {var d, e, f, g, h, i, j, k = r.css (a, "posición"), l = r (a), m = {}; " estática "=== k && (a.style.position =" relative "), h = l.offset (), f = r.css (a," top "), i = r.css (a, ), j = ("absoluto" === k || "fijo" === k) && (f + i) .indexOf ("auto" g = d.(e) = (a), (b) = b.call (a, c, r) .extend ({}, h))), null! = b.top && (m.top = b.top-h.top + g), null! = b.left && (m.left = b.left-h. (a) {if (arguments.length ()), () () () () ) return void 0 === a? this: this.each (function (b) {r.offset.setOffset (this, a, b)}); var b, c, d, e, f = this [0] ; if (f) return f.getClientRects (). length? (d = f.getBoundingClientRect (), b = f.ownerDocument, c = b.documentElement, e = b.defaultView, {top: d.top + e. {}: {top: 0, left: 0}}, posición: function () {if (this [0]) {var a, b, c = this [0], d = {top: 0, left: 0}, return "fixed" === r.css (c, "position") b = c.getBoundingClientRect () (), b = this.offset (), B (a [0], "html") || (d = a.offset ()), d = {top: d.top + r.css (a [0], "borderTopWidth",! 0), left: d.left + r.css (a [0], "borderLeftWidth",! 0)}, {top: b.top -d.top-r.css (c, "marginTop",! 0), left: b.left-d.left-r.css (c, "marginLeft",! 0)}}}, offsetParent: function ( ) {return this.map (function () {var a = this.offsetParent; while (a && "static" === r.css (a, "position")) a = a.offsetParent; return a || ra} ), r.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, función (a, b) {var c = "pageYOffset" === b; r.fn [a] = function d) {return T (this, function (a, d, e) {var f; return r.isWindow (a)? f = a: 9 === a.nodeType && (f = a.defaultView) void 0 = == e? f? f [b]: a [d]: void (f? f.scrollTo (c? f.pageXOffset: e, c? e: f.pageYOffset): a [d] = e) a, d, arguments.length)), r.each (["top", "left"], función (a, b) {r.cssHooks [b] = Pa (o.pixelPosition, function (a,c) {if (c) devuelve c = Oa (a, b), Ma.test (c)? r (a) .position () [b] + "px": c} {Altura: "altura", Ancho: "ancho"}, función (a, b) {función.a) (función de relleno: "interno" + a, contenido: b, "" c, d) {r.fn [d] = función (e, f) {var g = arguments.length && (c || "boolean"! = typeof e), h = c || (e ===! 0 || f ===! 0? margin ":" border "); return T (esto, función (b, c, e) {var f; return r.isWindow (b)? 0 === d.indexOf ("exterior")? b ["interno" + a]: b.document.documentElement ["cliente" + a]: 9 === b.nodeType? (f = b.documentElement, Math.max (b.body ["scroll" + a], f ["scroll" + a], b.body ["offset" + a], f ["offset" + a] (b, c, e, h)}, b, g? e: void 0, g)}})}), r.fn .extend ({bind: función (a, b, c) {return this.on (a, null, b, c)},(a, b, c, d) {return this.on (b, a, c, d)}, delegate: function (a, b) undelegate: función (a, b, c) {return 1 === arguments.length? this.off (a, "**"): this.off (b, a || "**", c)}} ), r.holdReady = function (a) {a? r.readyWait ++: r.ready (! 0)}, r.isArray = Array.isArray, r.parseJSON = JSON.parse, r.nodeName = B, "function "== typeof define && define.amd && define (" jquery ", [], function () {return r}); var Vb = a.jQuery, Wb = a. $; return r.noConflict = función (b) {return a. $ === r && (a. $ = Wb), b && a.jQuery === r && (a.jQuery = Vb), r}, b || (a.jQuery = a. $ = r), r});readyWait ++: r.ready (! 0)}, r.isArray = Array.isArray, r.parseJSON = JSON.parse, r.nodeName = B, "function" == typeof define && define.amd && define ("jquery", [ function () {return r}); var Vb = a.jQuery, Wb = a. $; return r.noConflict = function (b) {return a. $ === r && (a. $ = Wb), b && a. jQuery === r && (a.jQuery = Vb), r}, b || (a.jQuery = a. $ = r), r});readyWait ++: r.ready (! 0)}, r.isArray = Array.isArray, r.parseJSON = JSON.parse, r.nodeName = B, "function" == typeof define && define.amd && define ("jquery", [ function () {return r}); var Vb = a.jQuery, Wb = a. $; return r.noConflict = function (b) {return a. $ === r && (a. $ = Wb), b && a. jQuery === r && (a.jQuery = Vb), r}, b || (a.jQuery = a. $ = r), r});